<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control_General</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Control_General</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前提条件等"><a class="header" href="#前提条件等">前提条件等</a></h1>
<p>制御に関するお勉強・開発のHome<br />
基本的に<code>C言語</code>を用いる。一部<code>C++</code>などの他の言語の知識が混ざる可能性もある。環境構築等はすでに済んでいるものとし、コードの内容のみになることがある。<br />
各開発などのリポジトリは各ページに掲載していることもある。あくまで参考程度にしかならない。<br />
一部に自作のヘッダファイルなどを使用する場合がある。その場合は、そのファイルの中身などを簡単に説明する記事を作るように心掛ける。</p>
<p><strong>結局は自分で調べ、データシートなどを確認することがとても大事である。</strong></p>
<h3 id="使用環境"><a class="header" href="#使用環境">使用環境</a></h3>
<ul>
<li>Windows 11 Home</li>
<li>Ubuntu 22.04 LTS</li>
</ul>
<h3 id="使用使用予定のマイコンマイコンボード一覧"><a class="header" href="#使用使用予定のマイコンマイコンボード一覧">使用/使用予定のマイコン・マイコンボード一覧</a></h3>
<ul>
<li><a href="https://akizukidenshi.com/catalog/g/g110176/">NUCLEO-F446RE</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g110172/">NUCLEO-F303K8</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g107385/">Arduino Uno Rev3</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g116132/">Raspberry Pi Pico</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g117215/">ATOM Matrix</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g115674/">ESP32-WROVER-E</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本的なこと"><a class="header" href="#基本的なこと">基本的なこと</a></h1>
<p>ここではプログラムを作成するにあたって必要になってくる知識を軽く解説。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="BasicContents/./git_GitHub.html"><code>git</code>と<code>GitHub</code>の簡単な使い方について</a></li>
<li><a href="BasicContents/./motor.html">モーターの回転方向などの制御プログラムについて</a></li>
<li><a href="BasicContents/./ControllerData/controllerHome.html">コントローラーのデータのやり取りについて</a>
<ul>
<li><a href="BasicContents/./ControllerData/controllerTransmit.html">コントローラーのデータの送信側について</a></li>
<li><a href="BasicContents/./ControllerData/controllerTransmit.html">コントローラーのデータの受信側について</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitコマンドの使い方"><a class="header" href="#gitコマンドの使い方">gitコマンドの使い方</a></h1>
<p>バージョン管理ツール<code>git</code>の簡易的な使用方法をメモ。導入部分は省く。<br />
リモートとの通信には<code>ssh</code>を使用する。</p>
<ul>
<li><a href="BasicContents/git_GitHub.html#clone">clone</a></li>
<li><a href="BasicContents/git_GitHub.html#add">add</a></li>
<li><a href="BasicContents/git_GitHub.html#commit">commit</a></li>
<li><a href="BasicContents/git_GitHub.html#push">push</a></li>
<li><a href="BasicContents/git_GitHub.html#branch%E3%82%92%E5%88%86%E3%81%91%E3%82%8B">branch</a></li>
<li><a href="BasicContents/git_GitHub.html#tag">tag</a></li>
</ul>
<h2 id="基本"><a class="header" href="#基本">基本</a></h2>
<h3 id="clone"><a class="header" href="#clone">clone</a></h3>
<p>リモート(<code>GitHub</code>のサーバー)からリポジトリをローカル(自分のパソコン)に複製する。<br />
<code>git clone [remote URL]</code>でカレントディレクトリにそのリポジトリのディレクトリが複製される。<code>[remote URL]</code>は<code>GitHub</code>から確認する。<br />
<a href="https://github.com/">GitHub</a>に行きcloneしたいリポジトリのページまで移動する。緑色の<code>&lt;&gt;Code</code>を押し<code>Local</code>の<code>Clone</code>の<code>SSH</code>からコピーする。</p>
<h3 id="add"><a class="header" href="#add">add</a></h3>
<p>ローカルで変更したファイルなどをリモートにあげるファイルを選択する。<br />
<code>git add [ファイル名1] [ファイル名2] …</code></p>
<h3 id="commit"><a class="header" href="#commit">commit</a></h3>
<p>コミットを作成しリモートに<code>push</code>する。<code>add</code>したファイルをひとまとまりにする。<br />
<code>git commit -m "[コミットメッセージ]"</code><br />
コミットメッセージには何を更新したのかなどの内容を書いておくとよい。</p>
<h3 id="push"><a class="header" href="#push">push</a></h3>
<p>作成したコミットをリモートにあげる。<code>git push</code>でリモートを更新する。</p>
<h3 id="更新されたファイルなどがあるか確認"><a class="header" href="#更新されたファイルなどがあるか確認">更新されたファイルなどがあるか確認</a></h3>
<p><code>git status</code>で現在のリポジトリで更新されたファイルがあるかどうか、確認できる。</p>
<h3 id="リモートの変更をもってくる"><a class="header" href="#リモートの変更をもってくる">リモートの変更をもってくる</a></h3>
<p>他の端末などで変更を加え、リモートに反映させた。手元には反映前のコードなどがある。というときにわざわざディレクトリを削除してもう一度<code>clone</code>するのはめんどくさい。<code>git pull</code>を使用するとリモートの変更を反映させることができる。これは<code>git pull origin main</code>と同じことをしていて、リモートのmainブランチから<code>fetch</code>(変更をもってくるだけ
)と<code>merge</code>(変更を反映させる)を同時に行う。<code>merge</code>するときにローカルにリモートにはない変更があった場合は、手動でmerge作業を行う必要がある。</p>
<h2 id="branchを分ける"><a class="header" href="#branchを分ける">branchを分ける</a></h2>
<p>ふだんはおそらくmainブランチ、または、masterブランチを使用していると思われるが、開発用のブランチmainと更新用(リリースごと)のブランチreleaseに分けておきたいとする。mainブランチは日々の開発によりたくさんの更新が入りどのコミットでうまくいったのかがわからないこともある。ブランチは分けずにタグを作成して、そのときのコミットに戻れるという機能もあるがそれはbranchの次に紹介する。</p>
<h3 id="ブランチを作成"><a class="header" href="#ブランチを作成">ブランチを作成</a></h3>
<p>まずはブランチを作成する。<br />
<code>git branch release</code><br />
<code>release</code>という名前のブランチがローカルに作成された。<code>git branch</code>を実行すると現在ローカルにあるブランチの一覧を表示できる。</p>
<h3 id="ブランチに移動する"><a class="header" href="#ブランチに移動する">ブランチに移動する</a></h3>
<p>ブランチを作成したらそのブランチに移動する。<br />
<code>git checkout [ブランチ名]</code><br />
新しいブランチを作成していない場合は、<code>git checkout -b [ブランチ名]</code>で新しいブランチを作成しそのブランチに移動することができる。</p>
<h3 id="addしたりcommitしたり"><a class="header" href="#addしたりcommitしたり">addしたりcommitしたり</a></h3>
<p>あとは変更したファイルをaddしたりcommitしたりしても問題ない。<code>push</code>するときは<code>git push origin [ブランチ名]</code>とすると安心感がある。</p>
<h3 id="ブランチを他のブランチと同じバージョンまで持ってくる"><a class="header" href="#ブランチを他のブランチと同じバージョンまで持ってくる">ブランチを他のブランチと同じバージョンまで持ってくる</a></h3>
<p>mainブランチだけ先に進み、releaseブランチが遅れている場合、releaseブランチにmainブランチの状態にしたいなどということもあると思われる。そんなときにいちいちmainブランチからreleaseブランチにコピペするのは面倒くさい。そんなときに<code>merge</code>を使用する。<br />
進めたいブランチに<code>checkout</code>し、<code>git merge [進んでいるブランチ名]</code>を実行する。releaseブランチをmainブランチと同じ状態にしたい場合は、<code>git checkout release</code>、<code>git merge main</code>を実行することでreleaseブランチにmainブランチの変更を反映させることができる。<br />
このあとにreleaseブランチにpushし、リモートにも反映させる。</p>
<h3 id="ブランチの削除"><a class="header" href="#ブランチの削除">ブランチの削除</a></h3>
<p>ブランチが要らなくなったときに削除できるように。<br />
<code>git branch -d [ブランチ名]</code>でブランチを削除できる。これでローカルのブランチが削除された。<br />
<code>git push origin --delete [ブランチ名]</code>でリモートのブランチも削除することができる。</p>
<h3 id="確認"><a class="header" href="#確認">確認</a></h3>
<p>現在ローカルにあるブランチを確認するには<code>git branch</code>を使用する。<br />
リモートにあるブランチも確認するには<code>git branch -r</code>を使用する。</p>
<h2 id="tag"><a class="header" href="#tag">tag</a></h2>
<p>特定のバージョンに戻りたい(リリースバージョンとか)というときにリリースを作成するという事もできるがそれでは検索などに引っかかってしまう。それが嫌だという場合はtagを作成し、そのタグに戻ればよい。</p>
<h3 id="tagの作成とpush"><a class="header" href="#tagの作成とpush">tagの作成とpush</a></h3>
<p>タグを作成する前に変更などはすべてリモートに反映させておくとよい。<br />
<code>git tag -a [タグ名] -m "[タグのメッセージ]"</code><br />
これでローカルにtagを作成する。ローカルのcommitにtagがつけられる(と思われる)。<br />
<code>git push origin [タグ名]</code><br />
これにより、タグを作成し、作成したタグをリモートに反映することができる。</p>
<h3 id="tagの確認"><a class="header" href="#tagの確認">tagの確認</a></h3>
<p><code>git tag</code>でローカルにあるタグを確認できる。</p>
<h3 id="tagの削除"><a class="header" href="#tagの削除">tagの削除</a></h3>
<p><code>git tag -d [タグ名]</code>でローカルにあるタグを削除する。<code>git push origin --delete [タグ名]</code>でリモートにあるタグを削除する。</p>
<h4 id="参考"><a class="header" href="#参考">参考</a></h4>
<ul>
<li>授業・講座</li>
<li><a href="https://qiita.com/chihiro/items/e178e45a7fd5a2fb4599#git-branch---no-color">git branch コマンド</a></li>
<li><a href="https://backlog.com/ja/git-tutorial/">サル先生のGit入門</a></li>
<li><a href="https://youtu.be/LDOR5HfI_sQ?si=grgKMmUMKT4dgnn-">【Git入門】Git + Github使い方入門講座🐒Gitの仕組みや使い方を完全解説！パーフェクトGit入門！</a></li>
<li><a href="https://youtu.be/2mehreEA7yc?si=5BQeVtQgHnAOc_l_">GitHubの使い方を解説！ファイルの作成方法、ブランチの使い方が分かる！</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モーターのpwm制御"><a class="header" href="#モーターのpwm制御">モーターのPWM制御</a></h1>
<h2 id="pwmとは"><a class="header" href="#pwmとは">PWMとは</a></h2>
<p><code>PWM</code>とは、<code>Pulse Width Modulation</code>の略で<code>パルス幅変調</code>という。一定周期の中で出力が<code>HIGH</code>の長さと<code>LOW</code>の長さ比(デューティ比)で出力が決まる。</p>
<blockquote>
<p>出力が<code>5V</code>でデューティ比が<code>25%</code>であれば、出力は<code>1.25V</code>になる。出力電圧は以下の式で求められる。<br />
<code>(出力電圧) = (最大電圧) × (デューティ比)</code><br />
そのため、デューティ比が小さすぎると素子によってはデューティ比<code>0％</code>とあまり変わらない結果が得られるものもある。各素子の最低電圧などを確認すること。</p>
</blockquote>
<h2 id="モーターを回す"><a class="header" href="#モーターを回す">モーターを回す</a></h2>
<p>回路的には以下のようになっている。<br />
<img src="BasicContents/../resources/BasicContents/motor/motor_road.drawio.png" alt="motor_road.drawio.png" /><br />
モーターの動作電圧が<code>12V</code>でマイコンからの信号の電圧が<code>5V</code>か<code>3.3V</code>なので電圧を上げる必要がある。それをフォトカプラ基板で信号のやり取りを行っている。また、<code>PWM</code>の周期を<code>83[μs]</code>に設定する。これはモタドラICの周波数が<code>12[kHz]</code>あたりがいいらしいからだ(モタドラIC<code>HIP4081AIPZ</code>)。</p>
<h2 id="フォトカプラによる動作の違い"><a class="header" href="#フォトカプラによる動作の違い">フォトカプラによる動作の違い</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォトカプラ</th><th style="text-align: center">部品</th><th style="text-align: center">用途</th><th style="text-align: center">向き</th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/1611038?gb=a">TLP621</a></td><td style="text-align: center"><img src="BasicContents/../resources//BasicContents/motor/pic_TLP621.JPG" alt="pic_TLP621.JPG" /></td><td style="text-align: center">ディジタルの変換</td><td style="text-align: center">左下にある◯がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/1718031?cm_mmc=JP-PLA-DS3A-_-google-_-PLA_JP_JP_ePmax_Prio1-_--_-&amp;matchtype=&amp;&amp;campaignid=20858944244&amp;gad_source=1&amp;gclid=CjwKCAiArKW-BhAzEiwAZhWsIC59PvjUU27b9lFqq5lPOYafc83XY63O_NRmTJ4k13gT-4t-ofMuexoCSNoQAvD_BwE&amp;gclsrc=aw.ds">TLP521-2</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_TLP521-2.JPG" alt="pic_TLP521-2.JPG" /></td><td style="text-align: center">ディジタルの変換×2</td><td style="text-align: center">左下にある◯がマイコン側または、角が削れている方がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/2347111?srsltid=AfmBOop1mbTNh_2S3L3LVPv-URRDD3y03iuBuspMm1w5xkRcWY2EgoUm">PS9513</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_PS9513.JPG" alt="pic_PS9513.JPG" /></td><td style="text-align: center">PWMの変換</td><td style="text-align: center">左下にある◯がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/8851279?srsltid=AfmBOoqXYwz-_Yaf1EzdvjIdm6IBj3ft_dYQmsY4QKocpl6aMEDGDWGd">TLP250H</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_TLP250H.JPG" alt="pic_TLP250H.JPG" /></td><td style="text-align: center">PWMの変換</td><td style="text-align: center">左下にある◯がマイコン側または、角が削れている方がマイコン側</td></tr>
</tbody></table>
</div>
<p><strong>注意点</strong></p>
<ul>
<li><code>TLP521-2</code>はPWMの変換と同じような大きさだが内部の配線では<code>TLP621</code>が2個あるような配置になっている。PWMの変換には使用できないので注意。</li>
<li><code>PS9513</code>を標準とすると<code>TLP250H</code>は出力が反転している。例えば、入力に<code>0</code>が入っている場合<code>PS9513</code>では出力が<code>0</code>だが、<code>TLP250H</code>では<code>255</code>が出力される。使用するフォトカプラに合わせてコードを書き換える必要がある。</li>
</ul>
<h2 id="左回りと右回り正転と反転"><a class="header" href="#左回りと右回り正転と反転">左回りと右回り(正転と反転)</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">PWM側フォトカプラ</th><th style="text-align: center">Digi</th><th style="text-align: center">LOWの時のデューティ比</th><th style="text-align: center">HIGHの時のデューティ比</th><th style="text-align: center">回転方向</th><th style="text-align: center">出力波形部分</th></tr></thead><tbody>
<tr><td style="text-align: center">PS9513</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">左回り</td><td style="text-align: center">①</td></tr>
<tr><td style="text-align: center">PS9513</td><td style="text-align: center">1</td><td style="text-align: center">255</td><td style="text-align: center">0</td><td style="text-align: center">右回り</td><td style="text-align: center">②</td></tr>
<tr><td style="text-align: center">TLP250H</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">0</td><td style="text-align: center">左回り</td><td style="text-align: center">②</td></tr>
<tr><td style="text-align: center">TLP250H</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">右回り</td><td style="text-align: center">①</td></tr>
</tbody></table>
</div>
<p><code>出力波形</code><br />
<img src="BasicContents/../resources/BasicContents/motor/PWM_modu.png" alt="PWM_modu.png" /></p>
<h3 id="参考-1"><a class="header" href="#参考-1">参考</a></h3>
<ul>
<li><a href="https://deviceplus.jp/arduino/arduino_f04/">Arduino（アルディーノ）電子工作の基本④ LEDの明るさを調節する</a></li>
<li><a href="https://moons.link/post-632/">STM32 HALを使ってPWM出力してみる</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コントローラーで送受信するデータ"><a class="header" href="#コントローラーで送受信するデータ">コントローラーで送受信するデータ</a></h1>
<h2 id="通信モジュール"><a class="header" href="#通信モジュール">通信モジュール</a></h2>
<p>現在(2025/03/12)は、双葉電子の<code>FEP02TJ</code>を主に使用している。(<a href="https://www.futaba.co.jp/product/industry/industry_module/fep02">FEP-02</a>)<br />
周波数帯は<code>920MHz</code>帯で無線モジュール。<code>UART</code>を用いた通信が可能。部のほとんどのものがボードレート<code>38400[Symbol/sec(bit/s)]</code>に設定されている。</p>
<h2 id="rxとtx"><a class="header" href="#rxとtx">RXとTX</a></h2>
<p>マイコンボードのピン配置などで<code>UART1_RX</code>や<code>UART2_TX</code>などと書いてあるものを見たことがあると思う。<code>RX</code>は<code>Receive</code>の略で<code>TX</code>は<code>Transmit</code>の略でそれぞれ<code>受信する</code>、<code>送信する</code>という意味だ。無線モジュールを使用しない場合の多くは<code>Arduino</code>などの送信側の<code>TX</code>と<code>F446RE</code>などの受信側の<code>RX</code>をつなぎ送受信する。</p>
<h2 id="送信側"><a class="header" href="#送信側">送信側</a></h2>
<p>主に<code>Arduino Uno Rev3</code>に<code>USB Host Shield</code>を接続し、<code>USB Host Shield</code>に<code>DUALSHOCK4</code>などのコントローラーを接続し、<code>Arduino</code>でコントローラーのデータを読み取りそれをシリアル通信を用いて受信側に送る。受信データは以下の表の内容になって全てで<code>11byte</code>ある。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">byte数</th><th style="text-align: center">data</th><th style="text-align: center">説明</th></tr></thead><tbody>
<tr><td style="text-align: center">0byte</td><td style="text-align: center">0ｈxaf</td><td style="text-align: center">先頭データを表す</td></tr>
<tr><td style="text-align: center">1byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">LアナログスティックのX座標</td></tr>
<tr><td style="text-align: center">2byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">LアナログスティックのY座標</td></tr>
<tr><td style="text-align: center">3byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">RアナログスティックのX座標</td></tr>
<tr><td style="text-align: center">4byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">RアナログスティックのY座標</td></tr>
<tr><td style="text-align: center">5byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">L2アナログボタン</td></tr>
<tr><td style="text-align: center">6byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">R2アナログボタン</td></tr>
<tr><td style="text-align: center">7byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">ディジタルボタンセット1</td></tr>
<tr><td style="text-align: center">8byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">ディジタルボタンセット2</td></tr>
<tr><td style="text-align: center">9byte</td><td style="text-align: center">unsigned char</td><td style="text-align: center">チェックサム用SUM</td></tr>
<tr><td style="text-align: center">10byte</td><td style="text-align: center">0xed</td><td style="text-align: center">終端データを表す</td></tr>
</tbody></table>
</div>
<h3 id="ディジタルボタンセット1"><a class="header" href="#ディジタルボタンセット1">ディジタルボタンセット1</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">bit数</th><th style="text-align: center">data</th><th style="text-align: center">説明</th></tr></thead><tbody>
<tr><td style="text-align: center">0bit</td><td style="text-align: center">0/1</td><td style="text-align: center">TRIANGLE</td></tr>
<tr><td style="text-align: center">1bit</td><td style="text-align: center">0/1</td><td style="text-align: center">CIRCLE</td></tr>
<tr><td style="text-align: center">2bit</td><td style="text-align: center">0/1</td><td style="text-align: center">CROSS</td></tr>
<tr><td style="text-align: center">3bit</td><td style="text-align: center">0/1</td><td style="text-align: center">SQUARE</td></tr>
<tr><td style="text-align: center">4bit</td><td style="text-align: center">0/1</td><td style="text-align: center">UP</td></tr>
<tr><td style="text-align: center">5bit</td><td style="text-align: center">0/1</td><td style="text-align: center">RIGHT</td></tr>
<tr><td style="text-align: center">6bit</td><td style="text-align: center">0/1</td><td style="text-align: center">DOWN</td></tr>
<tr><td style="text-align: center">7bit</td><td style="text-align: center">0/1</td><td style="text-align: center">LEFT</td></tr>
</tbody></table>
</div>
<h3 id="ディジタルボタンセット2"><a class="header" href="#ディジタルボタンセット2">ディジタルボタンセット2</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">bit数</th><th style="text-align: center">data</th><th style="text-align: center">説明</th></tr></thead><tbody>
<tr><td style="text-align: center">0bit</td><td style="text-align: center">0/1</td><td style="text-align: center">L1</td></tr>
<tr><td style="text-align: center">1bit</td><td style="text-align: center">0/1</td><td style="text-align: center">L3</td></tr>
<tr><td style="text-align: center">2bit</td><td style="text-align: center">0/1</td><td style="text-align: center">R1</td></tr>
<tr><td style="text-align: center">3bit</td><td style="text-align: center">0/1</td><td style="text-align: center">R3</td></tr>
<tr><td style="text-align: center">4bit</td><td style="text-align: center">0/1</td><td style="text-align: center">CREATE / SHARE / SELECT</td></tr>
<tr><td style="text-align: center">5bit</td><td style="text-align: center">0/1</td><td style="text-align: center">OPTIONS / START</td></tr>
<tr><td style="text-align: center">6bit</td><td style="text-align: center">0/1</td><td style="text-align: center">PS</td></tr>
<tr><td style="text-align: center">7bit</td><td style="text-align: center">0/1</td><td style="text-align: center">TOUCHPAD / N/A</td></tr>
</tbody></table>
</div>
<p><code>N/A</code>:なし<br />
<code>SHARE</code>,<code>OPTIONS</code>,<code>TOUCHPAD</code>は<code>DUALSHOCK4</code>の場合、<code>SELECT</code>,<code>START</code>,<code>N/A</code>は<code>DUALSHOCK3</code>の場合。<br />
ボタンセットはボタンが押されている時に各bitが<code>1</code>になるようにしている。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">bit数</th><th style="text-align: center">16進数表記</th><th style="text-align: center">2進数表記</th></tr></thead><tbody>
<tr><td style="text-align: center">0bit</td><td style="text-align: center">0x01</td><td style="text-align: center">0000 0001</td></tr>
<tr><td style="text-align: center">1bit</td><td style="text-align: center">0x02</td><td style="text-align: center">0000 0010</td></tr>
<tr><td style="text-align: center">2bit</td><td style="text-align: center">0x04</td><td style="text-align: center">0000 0100</td></tr>
<tr><td style="text-align: center">3bit</td><td style="text-align: center">0x08</td><td style="text-align: center">0000 1000</td></tr>
<tr><td style="text-align: center">4bit</td><td style="text-align: center">0x10</td><td style="text-align: center">0001 0000</td></tr>
<tr><td style="text-align: center">5bit</td><td style="text-align: center">0x20</td><td style="text-align: center">0010 0000</td></tr>
<tr><td style="text-align: center">6bit</td><td style="text-align: center">0x40</td><td style="text-align: center">0100 0000</td></tr>
<tr><td style="text-align: center">7bit</td><td style="text-align: center">0x80</td><td style="text-align: center">1000 0000</td></tr>
</tbody></table>
</div>
<h3 id="チェックサム用sum"><a class="header" href="#チェックサム用sum">チェックサム用SUM</a></h3>
<p>SUM = <code>(LアナログスティックのX座標)</code> + <code>(LアナログスティックのY座標)</code> + <code>(RアナログスティックのX座標)</code> + <code>(RアナログスティックのY座標)</code> + <code>(L2アナログボタン)</code> + <code>(R2アナログボタン)</code> + <code>(ディジタルボタンセット1)</code> + <code>(ディジタルボタンセット2)</code></p>
<h2 id="受信側"><a class="header" href="#受信側">受信側</a></h2>
<p><code>NUCLEO-F446RE</code>などで<code>FEP</code>を通して<code>Arduino</code>から送られてきたデータはある処理をされて使用するデータに格納される。その処理はざっくり言うと以下の図のような処理になる。<br />
<img src="BasicContents/ControllerData/../../resources/BasicContents/ControllerData/controllerHome/rev.drawio.png" alt="rev.drawio.png" /><br />
各環境や言語によって使われる関数などは違うがだいたいはこのような感じの処理をしている。<br />
各環境の受信側ライブラリ(現在あるもの)</p>
<ul>
<li><a href="https://os.mbed.com/users/yabumi823/code/SerialCtrl/">Mbed(Keil Studio)</a></li>
<li><a href="https://github.com/s2301089/development-F446RE/tree/main/lib/UART_Arduino">STM32CubeIDE(F446RE)</a></li>
</ul>
<h3 id="ボタンセットの値の読み取り方"><a class="header" href="#ボタンセットの値の読み取り方">ボタンセットの値の読み取り方</a></h3>
<p>送信側ではボタンが押されたらbit論理和代入をしている。例えば<code>0x10</code>と<code>0x04</code>のボタンが押されている場合は<code>0001 0000 + 0000 0100 = 0001 0100</code>になる。そうすると送信側では、<code>0x14</code>が送信される。受信側では各ボタンの判定を行えば良く、ボタンが押されているかどうかは論理積を用いる。<code>0x10</code>の場合は<code>0x14 ・ 0x10 = 0x10</code>になる。このようにしてボタンの状態を読み取る。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="送信側transmit--tx"><a class="header" href="#送信側transmit--tx">送信側(Transmit / TX)</a></h1>
<h2 id="仕組み過去バージョン"><a class="header" href="#仕組み過去バージョン">仕組み(過去バージョン)</a></h2>
<p>このソースコードを作成する前までに使用していた通信の仕組みは<a href="BasicContents/ControllerData/./controllerHome.html">この</a>記事にまとめてある。</p>
<p>今回、作成したソースファイルとヘッダファイルに含まれている関数などの説明とこのプログラムファイルの使用方法などを簡易的に説明する。</p>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<h3 id="環境等"><a class="header" href="#環境等">環境等</a></h3>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
<li><a href="BasicContents/ControllerData/../platformIO.html">PlatformIO IDE</a></li>
<li><a href="https://docs.arduino.cc/hardware/uno-rev3/">Arduino Uno R3</a></li>
<li><a href="https://github.com/felis/USB_Host_Shield_2.0">USB Host Sheield 2.0</a></li>
</ul>
<h3 id="対応コントローラー"><a class="header" href="#対応コントローラー">対応コントローラー</a></h3>
<ul>
<li><a href="https://www.sony.com/ja/SonyInfo/design/gallery/CECH-ZC2/">DUAKSHOCK3(PlayStation3用コントローラー)</a></li>
<li><a href="https://www.playstation.com/ja-jp/accessories/dualshock-4-wireless-controller/">DUALSHOCK4(PlayStation4用コントローラー)</a></li>
<li><a href="https://www.playstation.com/ja-jp/accessories/dualsense-wireless-controller/">DUALSENSE(PlayStation5用コントローラー)</a></li>
</ul>
<h3 id="ソースファイルヘッダファイル"><a class="header" href="#ソースファイルヘッダファイル">ソースファイル・ヘッダファイル</a></h3>
<p>ソースファイル等はgitにてバージョン管理を行っている。現在(2025/05/10)時点での最新バージョンは<code>ver.1.1.0</code>であり<a href="https://github.com/s2301089/Control_General/tree/ver.1.1.0/codes/arduino_controller/PlayStationController/src">ここ</a>にある。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="受信側receive--rx"><a class="header" href="#受信側receive--rx">受信側(Receive / RX)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platformio"><a class="header" href="#platformio">PlatformIO</a></h1>
<p>2025Team_Bは<code>Keil Studio</code>を使用した制御プログラムの作成を辞め、他の開発環境への以降を考えている。Mbedのサポート終了が宣言されたからである。<a href="https://os.mbed.com/blog/entry/Important-Update-on-Mbed/">記事</a></p>
<h2 id="platform-ioを入れる"><a class="header" href="#platform-ioを入れる">Platform IOを入れる</a></h2>
<p><code>PlatformIO</code>は<code>ArduinoIDE</code>での書き方や<code>Keil Studio</code>での書き方などいろいろな書き方ができる。そしてこれは<code>VSCode</code>の拡張機能なので比較的導入が簡単なものである。
この拡張機能を使用して試しにコードを書き込むまでの記録。</p>
<h3 id="学内lanでは極力ダウンロードなどはしないようにしよう"><a class="header" href="#学内lanでは極力ダウンロードなどはしないようにしよう">学内LANでは極力ダウンロードなどはしないようにしよう</a></h3>
<blockquote>
<p>学内LANで<code>PlatformIO</code>のセッティングを行うためには<code>VSCode</code>自体のプロキシ設定が必要になる。<br />
<code>Ctrl + ,</code>で設定を開き、設定の検索バーで<code>proxy</code>と入力。<code>Http: Proxy(すべてのプロファイルに適用)</code>を探し、プロキシサーバーを入力する欄に学内LANのプロキシサーバー(<code>http://サーバーアドレス:ポート番号</code>)を入力し、保存し終わったら<code>VSCode</code>の再起動を行う。</p>
</blockquote>
<p><code>VSCode</code>で拡張機能のマーケットプレイスで、<code>PlatformIO IDE</code>をインストールする。<code>platformio.platformio-ide</code>これを検索バーに入力するか、<code>platform</code>とか検索する。<a href="https://marketplace.visualstudio.com/items/?itemName=platformio.platformio-ide">link</a></p>
<p>インストール中に<code>PlatformIO: Can not find working Python 3.6+ Interpreter. Please install the latest Python 3 and restart VSCode</code>こんな表示がでてくるかもしれない。これは<code>Python 3.6</code>以上が見つかりませんって言われているだけ。<code>Python</code>をインストールしていない人は<code>Install Python</code>を押して<a href="https://www.python.org/downloads/">サイト</a>からWindows用をダウンロードする。もうインストールしてある人は<code>I have Python</code>てきなところを押せばいいと思われ。僕はインストールしてなかったからインストールする。</p>
<p><code>Python</code>のインストーラーをダウンロードしたら、Pythonのインストーラーを実行。下のチェックボックス欄の<code>Add Python.exe to PATH</code>にチェックを入れる。<code>Use admin privileges when installing py.exe</code>のチェックは管理者権限ですべてのユーザーにインストールするみたいな項目だから、チェックしてなくて問題ない。チェックが終わったら<code>Install Now</code>を押してインストールする。<br />
<code>Setup was Successful</code>がでたら<code>Close</code>を押してもよいけど、<code>Disable path length limit</code>っていう項目が残っている。これはパスの長さの制限をなくしますか？っていう項目だから押しておけば今後何も考えなくていい。幼くても別に問題はないかも。(僕は押した)<br />
そしたら<code>VSCode</code>を再起動してほかのインストールが終わるのを待つ。</p>
<h2 id="platformioを使う"><a class="header" href="#platformioを使う">PlatformIOを使う</a></h2>
<p><code>VSCode</code>のバーのところから蜂のようなアイコンを探す。で、<code>Create New Project</code>を押して新規作成する。<code>PIO Home</code>が開くと思うから<code>Quick Access</code>のところから<code>New Project</code>を押してプロジェクトを新規作成する。<br />
Name:はプロジェクトの名前をつける。個人的にはスペース、日本語を含まない半角英数字のみで名前を決めるのがいい(なんかそれしか使えないっぽいけど)。Board:は使用するボードの選択。今回は<code>Arduino Uno R3</code>を使用するので<code>Arduino Uno</code>を選択した。Framework:は使う書き方てきな感じだと思われ。<code>Arduino</code>を選択(これしかなかった)した。Location:はプロジェクトを保存する場所を選ぶ。デフォルトの場所はどこかわからないけど自分でわかりやすいところに置くべきだと思う。場所を指定するときは<code>Use default location</code>のチェックを外すと選べる画面がでてくるからそこから選ぶ。何回もその場所を使用したいと思うときは☆マークをつけれるところがあるからそこにつけておくとたぶん<code>Favorites</code>のところに次回からも表示されると思う。フォルダを選択したら下の<code>Finish</code>を押す。一番最初に作成するときは結構時間がかかるかもしれない。気長に待とう。作成が終わったら勝手に<code>platformio.ini</code>ってのが開くと思う。フォルダツリーの<code>src</code>ってところに<code>main.cpp</code>があるからそこがメインとなるファイル。基本そこに記述していけば問題ないかも。<br />
<code>#include</code>のところに波線が引いていたりしたら正しくライブラリを読み込めてないから<code>PIO Home</code>を開いて(蜂マーク選べばたぶん開く)<code>Open Project</code>からプロジェクトフォルダを選択する。<br />
ためしにLチカのコードを書いてみる。<br />
<code>main.cpp</code></p>
<pre><code class="language-cpp">#include &lt;Arduino.h&gt;

bool x = 0;

void setup() {
  // put your setup code here, to run once:
  pinMode(13,OUTPUT);
}

void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(13,x);
  delay(250);
  x = x ^ 1;
}
</code></pre>
<p>これは<code>250ms</code>間隔でボードに付いているLEDを点滅させるプログラム。パソコンにボードをつなげて、右上の三角ボタンの下矢印から<code>Upload</code>を選択して書き込みをする。SUCCESSってでたら書き込み完了。<br />
<code>main.cpp</code></p>
<pre><code class="language-cpp">#include &lt;Arduino.h&gt;

bool x = 0;

void setup() {
  // put your setup code here, to run once:
  pinMode(13,OUTPUT)
}

void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(13,x);
  delay(250);
  x = x ^ 1;
}
</code></pre>
<p>このコードでは以下のようなエラーが出ると思う。これは<code>pinMode</code>の後に<code>;</code>がないからコンパイルエラーとしてでている。<code>;</code>をつけ直せばきちんとコンパイルが通り書き込まれるだろう。</p>
<pre><code class="language-bash">src\main.cpp: In function 'void setup()':
src\main.cpp:8:1: error: expected ';' before '}' token
 }
 ^
*** [.pio\build\uno\src\main.cpp.o] Error 1
</code></pre>
<p><code>x</code>の値をシリアルモニターに出力したい(画面に出力したい)と思ったら、以下のようにコードを追記する。<br />
<code>main.cpp</code></p>
<pre><code class="language-cpp">#include &lt;Arduino.h&gt;

bool x = 0;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(38400);
  pinMode(13,OUTPUT);
}

void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(13,x);
  Serial.println(x);
  delay(250);
  x = x ^ 1;
}
</code></pre>
<p>ターミナルがあるバーにシリアルモニターっていう項目があると思うからそこから見る。監視の開始を押すと見れると思う。試してみたら更新がカクカクしてて見づらかったから<code>Tera Term</code>とかで見ることをおすすめする。<code>Tera Term</code>で見ようとしたらシリアルモニターの方で監視の停止をしないと見れないだろうからそこには注意する。</p>
<p>以上！</p>
<h3 id="参考-2"><a class="header" href="#参考-2">参考</a></h3>
<ul>
<li><a href="https://tech.nri-net.com/entry/arduino_with_vscode">ArduinoをVSCodeで開発する【PlatformIO】</a></li>
<li><a href="https://qiita.com/cointoss1973/items/b3c84daeed90fd183501">Visual Studio Code に Proxy を設定する方法</a></li>
<li><a href="https://www.python.jp/install/windows/install.html">Windows版Pythonのインストール</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arduinoideでの開発"><a class="header" href="#arduinoideでの開発">ArduinoIDEでの開発</a></h1>
<p><code>PlatformIO</code>に移行する前まで主に<code>Arduino Uno Rev3</code>や<code>Raspberry Pi Pico</code>などのマイコンボードの開発に使用してきた。しかし、2025年度ではすべてのプログラムの作成を<code>PlatformIO</code>で行うことに統一し<code>ArduinoIDE</code>は使用しないように方向転換している。<br />
しかし、<code>PlatformIO</code>で<code>Arduino</code>のプログラムを作成するためにframeworkに<code>Arduino</code>を選択することになる。その場合は、<code>ArduinoIDE</code>で書いてきたような関数を使用する。そのためには、<code>ArduinoIDE</code>で書いてきたプログラムの基礎知識が必要になってくる。その簡単な関数などを軽く紹介する。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentArduinoIDE/./DigitalInOut/digitalOut.html">ディジタル出力をする</a></li>
<li><a href="DevelopmentArduinoIDE/./SerialPrint.html">変数などの値を見れるようにする</a></li>
</ul>
<h2 id="開発を始める前に"><a class="header" href="#開発を始める前に">開発を始める前に</a></h2>
<ul>
<li><a href="https://karakuri-musha.com/inside-technology/arduino-raspberrypi-pico-helloworld01/"><code>Raspberry Pi Pico</code>を使用するために</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ディジタル出力"><a class="header" href="#ディジタル出力">ディジタル出力</a></h1>
<h2 id="ディジタル出力をしてlチカをする"><a class="header" href="#ディジタル出力をしてlチカをする">ディジタル出力をしてLチカをする</a></h2>
<p><code>Raspberry Pi Pico</code>のLチカ(LEDをチカチカさせる)コードを作成。<br />
どのピンを使用するかどうかは<a href="https://akizukidenshi.com/goodsaffix/Pico-R3-A4-Pinout.pdf">これ</a>を参考にした。<br />
<code>digiout.ino</code></p>
<pre><code class="language-cpp">#define LED 2
int x = 0;

void setup(){
    pinMode(LED,OUTPUT);
}

void loop(){
    digitalWrite(LED,x);
    x = !x;
    delay(500);
}
</code></pre>
<p><code>500ms</code>ごとにLEDが点灯消灯を繰り返すプログラム。<code>GP2</code>のピンで出力が行われる。おそらくピンの宣言では<code>GP◯</code>の◯の数字を<code>pinMode(ピン名,用途)</code>のピン名に入れればいいだろう。</p>
<h3 id="参考-3"><a class="header" href="#参考-3">参考</a></h3>
<ul>
<li><a href="https://deviceplus.jp/arduino/arduino_f03/">Arduino（アルディーノ）電子工作の基本③ デジタル出力でLEDを点灯制御しよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数値などの表示"><a class="header" href="#変数値などの表示">変数値などの表示</a></h1>
<h2 id="printfみたいなことをする"><a class="header" href="#printfみたいなことをする">printfみたいなことをする</a></h2>
<p>変数の値などを表示させたいときなどにシリアルモニタに値を出力する。<code>Raspberry Pi Pico</code>とパソコンでシリアル通信を用いてデータをやり取りしている。<br />
<code>printf01.ino</code></p>
<pre><code class="language-cpp">int x = 0;

void setup(){
    Serial.begin(38400);
}

void loop(){
    if(x &gt; 100){
        x = 0;
    }
    Serial.println(x);
    x++;
    delay(100);
}
</code></pre>
<p>これは<code>0~100</code>までの値を<code>0.1s</code>ごとに<code>1</code>ずつ値を増やし表示する。</p>
<p><code>Serial.print</code>,<code>Serial.println</code>は一つの変数または、一つの文字列しかその関数では表示できない。<code>printf</code>関数みたいに表示形式を指定するためには<code>sprintf</code>関数を使用する。(使用するボードによっては<code>Serial.printf</code>関数も使用できるっぽい。これは<code>printf</code>みたいな関数)<br />
<code>printf02.ino</code></p>
<pre><code class="language-cpp">int x = 33;

void setup(){
  Serial.begin(38400);
}

void loop(){
  if(x &gt; 126){
    x = 33;
  }
  char buf[100] = {};
  sprintf(buf,"%3d 0x%02X %c \n",x,x,x);
  Serial.print(buf);
  x++;
  delay(100);
}
</code></pre>
<p>これはASCIIコードの33番(<code>!</code>)~126番(<code>~</code>)までを<code>0.1s</code>ごとに表示するプログラム。表示形式は(xを整数3桁 0x(xを大文字の16進数2桁空白0埋め) xの値に対応する文字)で出力される。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32cubeideでの開発"><a class="header" href="#stm32cubeideでの開発">STM32CubeIDEでの開発</a></h1>
<p>基本的に<code>NUCLEO-F446RE</code>を用いた。2024年度春休みに<code>Keil Studio</code>でない開発環境を使用するために使用してみた。その時の記録。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/BasicContentsHome.html">はじめにやっておくと便利になること</a>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/printf.html"><del>変数などを表示するために</del></a></li>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/printfLibrary.html">変数などを簡単に表示するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/manydef.html">ピンの名前などを簡単に入力するために</a></li>
</ul>
</li>
</ul>
<h2 id="開発を始める前に-1"><a class="header" href="#開発を始める前に-1">開発を始める前に</a></h2>
<ul>
<li><a href="https://qiita.com/usashirou/items/65be086c28f7a6feac7d"><code>STM32CubeIDE</code>の導入</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本的なこと-1"><a class="header" href="#基本的なこと-1">基本的なこと</a></h1>
<p>ここではプロジェクトを作成した後にやっておくと便利なことを軽く解説。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html"><del>変数などを表示するために</del></a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printfLibrary.html">変数などを簡単に表示するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./manydef.html">ピンの名前などを簡単に入力するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./generateBinaryFile.html">バイナリファイル(.bin)の生成</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数などを表示するために"><a class="header" href="#変数などを表示するために">変数などを表示するために</a></h1>
<h2 id="printfを使って変数の値などを見れるようにする"><a class="header" href="#printfを使って変数の値などを見れるようにする">printfを使って変数の値などを見れるようにする</a></h2>
<p>マイコンとパソコンとの間で<code>UART</code>を用いて通信を行う。パソコン側では<code>TeraTerm</code>を用いてシリアルポートを監視する。</p>
<h2 id="cubeideの設定"><a class="header" href="#cubeideの設定">CubeIDEの設定</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART2</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART2</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
/* USER CODE END Includes */

/* USER CODE BEGIN 1 */
setbuf(stdout,NULL);
/* USER CODE END 1 */

/* USER CODE BEGIN 3 */
    printf("Hello World\r\n");
    HAL_Delay(250);
}
/* USER CODE END 3 */

/* USER CODE BEGIN 4 */
int _write(int file,char *ptr,int len){
    HAL_UART_Transmit(&amp;huart2, (uint8_t *)ptr, len, 10);
    return len;
}
/* USER CODE END 4 */
</code></pre>
<h2 id="teratermの設定"><a class="header" href="#teratermの設定">TeraTermの設定</a></h2>
<p><code>TeraTerm</code>を開いて<code>ファイル</code>-<code>新しい接続</code>-<code>シリアル</code>-<code>COM◯: STMicroelectronics STLink Virtual COM Port (COM◯)</code>-<code>OK</code>でマイコンと接続する。<code>設定</code>-<code>シリアルポート</code>-<code>スピード</code>を<code>CubeIDE</code>側で設定した<code>Baud Rate</code>を入力。ここでは<code>38400</code>と設定。<code>現在の接続を再設定</code>で設定を完了させる。</p>
<h3 id="参考-4"><a class="header" href="#参考-4">参考</a></h3>
<ul>
<li><a href="https://yukblog.net/stm32cubeide-printf-uart/">【便利】STM32CubeIDEでprintf【UART編】</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数などを簡単に表示するために"><a class="header" href="#変数などを簡単に表示するために">変数などを簡単に表示するために</a></h1>
<p><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html">変数などを表示するために</a>で<code>printf</code>する方法を紹介したが、いちいち<code>int _write</code>とか書くのがめんどくさくなったので処理をまとめた。</p>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART2</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART2</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "STprintf.h"
/* USER CODE END Includes */

/* USER CODE BEGIN 2 */
STprintf(&amp;huart2);
uint8_t Out[8] = {0};
/* USER CODE END 2 */

/* USER CODE BEGIN 3 */
    printf("Hello World\r\n");
    HAL_Delay(250);
}
/* USER CODE END 3 */

</code></pre>
<p><code>STprintf</code>関数の引数にUARTのポインタを渡すだけで<code>printf</code>が使えるようになる。</p>
<h2 id="teratermの設定-1"><a class="header" href="#teratermの設定-1">TeraTermの設定</a></h2>
<p><code>TeraTerm</code>を開いて<code>ファイル</code>-<code>新しい接続</code>-<code>シリアル</code>-<code>COM◯: STMicroelectronics STLink Virtual COM Port (COM◯)</code>-<code>OK</code>でマイコンと接続する。<code>設定</code>-<code>シリアルポート</code>-<code>スピード</code>を<code>CubeIDE</code>側で設定した<code>Baud Rate</code>を入力。ここでは<code>38400</code>と設定。<code>現在の接続を再設定</code>で設定を完了させる。</p>
<h3 id="参考-5"><a class="header" href="#参考-5">参考</a></h3>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html">変数などを表示するために</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="名前を楽するlib"><a class="header" href="#名前を楽するlib">名前を楽する(lib)</a></h1>
<p><code>GPIOA</code>とか<code>GPIO_PIN_1</code>とか<code>TIM_Channel_3</code>とか書くのがめんどくなったので楽にした。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">もともと</th><th style="text-align: center">いま</th></tr></thead><tbody>
<tr><td style="text-align: center">GPIO_PIN_0</td><td style="text-align: center">P0</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIO_PIN_15</td><td style="text-align: center">P15</td></tr>
<tr><td style="text-align: center">GPIO_PIN_ALL</td><td style="text-align: center">Pall</td></tr>
<tr><td style="text-align: center">GPIO_PIN_0</td><td style="text-align: center">GPIO_Pin_0</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIO_PIN_15</td><td style="text-align: center">GPIO_Pin_15</td></tr>
<tr><td style="text-align: center">GPIO_PIN_ALL</td><td style="text-align: center">GPIO_Pin_ALL</td></tr>
<tr><td style="text-align: center">GPIOA</td><td style="text-align: center">PA</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIOH</td><td style="text-align: center">PH</td></tr>
<tr><td style="text-align: center">TIM_CHANNEL_1</td><td style="text-align: center">TIMCH_1</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">TIM_CHANNEL_4</td><td style="text-align: center">TIMCH_4</td></tr>
<tr><td style="text-align: center">TIM_CHANNWL_ALL</td><td style="text-align: center">TIMCH_ALL</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="バイナリファイルbinの生成"><a class="header" href="#バイナリファイルbinの生成">バイナリファイル(.bin)の生成</a></h1>
<h2 id="エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する"><a class="header" href="#エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する">エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する</a></h2>
<p><code>CubeIDE</code>では<code>binファイル</code>は実行時やデバッグ時に自動で生成され、実行時、デバッグ時毎に上書き保存される。設定を変更するだけで生成されるようになる。<br />
<code>[プロジェクト名]</code>を右クリック、<code>プロパティ</code>-<code>C/C++ ビルド</code>-<code>設定</code>-<code>ツール設定</code>-<code>MCU/MPU Post build outputs</code>の<code>Convert to binary file</code>の項目にチェックを入れ、適用して閉じる。
<code>binファイル</code>の他にも<code>HEXファイル</code>や<code>SRECファイル</code>などの他のファイル形式のファイルも設定すれば、生成できる。<br />
<code>binファイル</code>は生成されるとプロジェクトの中の<code>Debugフォルダ</code>に<code>[プロジェクト名].bin</code>という名前で生成される。</p>
<h3 id="参考-6"><a class="header" href="#参考-6">参考</a></h3>
<ul>
<li><a href="https://yukblog.net/stm32cubeide-hex/">STM32CubeIDEでHEXファイルを作成する方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入出力"><a class="header" href="#入出力">入出力</a></h1>
<p>ディジタルやアナログの入出力に関して軽く解説。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./digitalInOut.html">ディジタル入出力をする</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./OutTimerLED.html">タイマー割り込みを使用したLチカ</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./OutPWM.html">PWM出力をする(タイマー)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./InVariableResistance.html">可変抵抗の値を読む(アナログ入力・タイマー)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./InRotaryEncoder.html">ロータリーエンコーダーを読む(タイマー)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ディジタル入出力"><a class="header" href="#ディジタル入出力">ディジタル入出力</a></h1>
<h2 id="ledを点灯させたりプッシュスイッチの値を読み込んだりする"><a class="header" href="#ledを点灯させたりプッシュスイッチの値を読み込んだりする">LEDを点灯させたり、プッシュスイッチの値を読み込んだりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Pinout view</code>から使いたいピンを選択する。今回は<code>PA_1</code>を<code>GPIO_Input</code>、<code>PA_0</code>を<code>GPIO_Output</code>に設定した。ピンを選ぶときには使用するマイコンボードのMbedのページ(ここでは<a href="https://os.mbed.com/platforms/ST-Nucleo-F446RE/">NUCLEO-F446RE</a>)の<code>Morpho headers</code>を見ながら選ぶといいかもしれない。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN 2 */
int psw1;
/* USER CODE END 2 */

/* USER CODE BEGIN 3 */
    psw1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1); // ディジタル入力
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, psw1); // ディジタル出力
}
/* USER CODE END 3 */
</code></pre>
<p>使用する回路によって動作は異なるがプルアップ抵抗を用いたプッシュスイッチの回路であれば、スイッチを押すとLEDは消灯し、離すとLEDは点灯するだろう。</p>
<h3 id="参考-7"><a class="header" href="#参考-7">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/30e522589db9f7dc8fe4">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(4) スイッチを使ってみよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="タイマー割り込みによるlチカ"><a class="header" href="#タイマー割り込みによるlチカ">タイマー割り込みによるLチカ</a></h1>
<h2 id="hal_delayを使わないでlチカをする"><a class="header" href="#hal_delayを使わないでlチカをする">HAL_Delay()を使わないでLチカをする</a></h2>
<p>今までLチカは以下のようなコードでしていた。</p>
<pre><code class="language-c">HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_0);
HAL_Delay(1000);
</code></pre>
<p>これは毎秒Lチカするプログラムである。このコードでは次にLEDの状態を変えるまで処理をすべて止めている。そのため、他の処理をしようとしてもできなかった。そんなときにタイマー割り込みを使用すれば他の処理を止めることなく、一定の周期である処理を実行することができる。<br />
<code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM2</code>-<code>Mode</code>-<code>Clock Source</code>を<code>Internal Clock</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Prescaler</code>を<code>15</code>、<code>Counter Period</code>を<code>999999</code>に、<code>Configuration</code>-<code>NVIC Setting</code>-<code>TIM2 global interrupt</code>を<code>Enable</code>に設定。今回は<code>TIM2</code>を使用した。<br />
<code>main.c</code></p>
<pre><code class="language-c">/* USER CODE BEGIN 2 */
HAL_TIM_Base_Start_IT(&amp;htim2);
/* USER CODE END 2 */

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){
    HAL_GPIO_TogglePin(GPIOxA, GPIO_Pin_0);
}
/* USER CODE END 4 */
</code></pre>
<p><code>HAL_TIM_PeriodElapsedCallback</code>関数は割り込みをした時に実行される関数であるため、そこにLチカのコードを書く。<br />
割り込み周期は設定した<code>Prescaler</code>と<code>Counter Period</code>、内部クロック周波数で決まる。内部クロック周波数はデフォルトでは<code>16MHz</code>だが変更したいまたは。確認したい場合は<code>ioc</code>ファイルの<code>Clock Configuration</code>-<code>APB1 Timer clocks(MHz)</code>で確認する(たぶん)。割り込み周期は以下の式で求められる。<br />
$$f = \frac{(内部クロック周波数)}{(Prescaler + 1) \times (Counter \space Period + 1)}$$<br />
また、周期は周波数の逆数なので周期から求めると、<br />
$$ T = \frac{1}{f} = \frac{(Prescaler + 1) \times (Counter \space Period + 1)}{(内部クロック周波数)} $$<br />
となる。おすすめとしては<code>Prescaler</code>を<code>15</code>として<code>Counter Period</code>の値を変更するとわかりやすいかもしれない。<br />
上記の例では<code>Prescaler</code>が<code>15</code>で<code>Counter Period</code>が<code>999999</code>なので周期は、<br />
$$ \frac{(15 + 1)(999999 + 1)}{16 \times 10^6} = 1[s] $$<br />
となり、毎秒Lチカするプログラムになっている。</p>
<h3 id="参考-8"><a class="header" href="#参考-8">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/e02b798b4bf1b92a4546">STM32CubeIDEを使ってみよう How To STM32CubeIDE 日本語版 (15) TimerでLチカしよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwm出力"><a class="header" href="#pwm出力">PWM出力</a></h1>
<h2 id="ledの明るさを変更したりモーターの回転速度を変更したりする"><a class="header" href="#ledの明るさを変更したりモーターの回転速度を変更したりする">LEDの明るさを変更したり、モーターの回転速度を変更したりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM3</code>-<code>Mode</code>-<code>Channel3</code>を<code>PWM Generation CH3</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Prescaler</code>を<del><code>83</code></del><code>4</code>、<code>Counter Period</code>を<del><code>999</code></del><code>255</code>、<code>PWM Generation Channel3</code>-<code>Output compare preload</code>を<code>Disable</code>に設定。今回は<code>TIM3</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN WHILE */
while (1)
{
    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    __HAL_TIM_SET_COMPARE(&amp;htim3,TIM_CHANNEL_3,100);
}
/* USER CODE END 3 */
</code></pre>
<p><code>100</code>がパルス幅にあたる部分であり、範囲は<code>0</code>~<code>255</code>にする。<br />
範囲やPWM周期などは<code>Prescaler</code>や<code>Counter Period</code>などから求められる。式については<a href="DevelopmentSTM32CubeIDE/InOut/./OutTimerLED.html">ここ</a>に記載している。<code>Counter Period</code>が<code>範囲の個数-1</code>であるということだけは覚えていて欲しい。</p>
<h3 id="参考-9"><a class="header" href="#参考-9">参考</a></h3>
<ul>
<li><a href="https://moons.link/post-632/">STM32 HALを使ってPWM出力してみる</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アナログ入力"><a class="header" href="#アナログ入力">アナログ入力</a></h1>
<h2 id="可変抵抗の値を読み取ったりセンサの値を読み取ったりする"><a class="header" href="#可変抵抗の値を読み取ったりセンサの値を読み取ったりする">可変抵抗の値を読み取ったり、センサの値を読み取ったりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Pinout view</code>から使いたいピンを選択する。今回は<code>PA_4</code>を<code>ADC1_IN4</code>に設定した。ピンを選ぶときには使用するマイコンボードのMbedのページ(ここでは<a href="https://os.mbed.com/platforms/ST-Nucleo-F446RE/">NUCLEO-F446RE</a>)の<code>Morpho headers</code>を見ながら選ぶといいかもしれない。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN 2 */
float resi1;
/* USER CODE END 2 */

/* USER CODE BEGIN WHILE */
while (1)
{
    HAL_ADC_Start(&amp;hadc1);
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    HAL_ADC_PollForConversion(&amp;hadc1, 100);
    resi1 = HAL_ADC_GetValue(&amp;hadc1);
    printf("%f\r\n",resi1);
    HAL_Delay(250);
}
/* USER CODE END 3 */
</code></pre>
<p><code>float</code>型を<code>printf</code>するために、設定を変更する。<code>[プロジェクト名]</code>を右クリック、<code>プロパティ</code>-<code>C/C++ ビルド</code>-<code>設定</code>-<code>ツール設定</code>-<code>MCU/MPU Settings</code>の<code>Use float with printf from newlib-nano</code>の項目にチェックを入れ、適用して閉じる。<br />
今回は可変抵抗を用いてアナログ入力値の変化を出力した。<code>printf</code>を使えるようにするためには、他の設定やコードが必要。<a href="DevelopmentSTM32CubeIDE/InOut/../BasicContents/printfLibrary.html">これ</a>を参考にした。</p>
<h3 id="参考-10"><a class="header" href="#参考-10">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/e6b5d0529524a140ebaf">STM32CubeIDEを使ってみよう How To STM32CubeIDE 日本語版 (12) ADCを使ってみよう</a></li>
<li><a href="https://yukblog.net/stm32cubeide-printf-float/">STM32CubeIDEのprintfでfloatが使えない件の対処方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ロータリーエンコーダを読む"><a class="header" href="#ロータリーエンコーダを読む">ロータリーエンコーダを読む</a></h1>
<p>エンコーダは<a href="https://www.digikey.jp/ja/products/detail/same-sky-formerly-cui-devices-/AMT102-V/827015?gclsrc=aw.ds&amp;&amp;utm_adgroup=&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=Pmax%20Shopping_Product_Medium%20ROAS&amp;utm_term=&amp;productid=827015&amp;utm_content=&amp;utm_id=go_cmp-20190420439_adg-_ad-__dev-c_ext-_prd-827015_sig-Cj0KCQjwhMq-BhCFARIsAGvo0KepiliL5UMokL4bXzAq1rxj0amR6aMMbkjXr6ANuMr8IIp5-BnlpJoaArLIEALw_wcB&amp;gad_source=1&amp;gclid=Cj0KCQjwhMq-BhCFARIsAGvo0KepiliL5UMokL4bXzAq1rxj0amR6aMMbkjXr6ANuMr8IIp5-BnlpJoaArLIEALw_wcB&amp;gclsrc=aw.ds">AMT102-V</a>を使用した。</p>
<p>エンコーダを読むことで移動距離などを計算できる。エンコーダにはA相とB相を用いて回転方向と回転量をアナログ値として読み取ることができるらしい。<br />
マイコンのピンの<code>SPI◯_MISO</code>と<code>SPI◯_MOSI</code>の機能を使用していると予想。タイマーのエンコーダモードを使用する。<br />
<code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM3</code>-<code>Mode</code>-<code>Combined Channels</code>を<code>Encoder Mode</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Counter Period</code>を<code>8192</code>、<code>Encoder</code>-<code>Encoder Mode</code>を<code>Encoder Mode TI1 and TIT2</code>に設定。今回は<code>TIM3</code>を使用した。<br />
<code>printf</code>を使用する。<br />
<code>main.c</code></p>
<pre><code class="language-c">/* USER CODE BEGIN 0 */
int over;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){
    if(htim-&gt;Instance == TIM3){
        __HAL_TIM_CLEAR_FLAG(&amp;htim3,TIM_IT_UPDATE);
        if(__HAL_TIM_IS_TIM_COUNTING_DOWN(&amp;htim3)){
            over--;
        }else{
            over++;
        }
    }
}
/* USER CODE END 0 */

/* USER CODE BEGIN 2 */
STprintf(&amp;huart2);
HAL_TIM_Encoder_Start(&amp;htim3, TIMCH_ALL);
HAL_TIM_Base_Start_IT(&amp;htim3);
int count;
over = 0;
/* USER CODE END 2 */

/* USER CODE BEGIN WHILE */
while (1)
{
    // count = TIM3 -&gt; CNT;
    count = (long)(over * 8192) + (long)TIM3 -&gt; CNT;
    printf("%d\r\n",count);
    HAL_Delay(100);
/* USER CODE END WHILE */
</code></pre>
<p>エンコーダの回転量を<code>TIM3 -&gt; CNT</code>でゲットし表示する。ただ<code>8192</code>を上回るまたは<code>0</code>を下回ると<code>8192</code>から<code>0</code>にまたは<code>0</code>から<code>8192</code>に飛ぶ。<br />
それを解決するためにオーバーフローを検知しその回数を記録し<code>count</code>に反映させる。<code>HAL_TIM_PeriodElapsedCallback</code>関数はオーバーフローが起こった時に実行される関数であるため、そこにオーバーフローの回数を記録する。一回転が<code>8192</code>であるから<code>over * 8192</code>で増分を増やす。一回転が<code>8192</code>であるのはエンコーダのデータシートに記載されていて内部のディップスイッチが<code>1</code>~<code>4</code>までが全て<code>0</code>になっている場合、一回転は<code>2048 * 4</code>の<code>8192</code>になると書かれている。</p>
<p style="text-align:center"><img src="DevelopmentSTM32CubeIDE/InOut/../../resources/DevelopmentSTM32CubeIDE/InOut/InRotaryEncoder/encoder_inside.JPG" alt="encoder_inside.JPG" width="400"></p>  
<h2 id="角度を求めてみる"><a class="header" href="#角度を求めてみる">角度を求めてみる</a></h2>
<p>回転量から回転回数や基準からの角度などを求められる。<code>((float)count / 8192) * 360</code>で1周<code>360°</code>になる。ただし<code>count</code>はもともと<code>int</code>型なので計算結果を少数にするために<code>float</code>型にキャスト変換する。また、以下のコードで角度を<code>0°</code>~<code>360°</code>にすることで何周しても同じ角度になるようにすることができる。<br />
<code>以下のコード</code></p>
<pre><code class="language-c">while(deg &gt; 360){
    deg = deg - 360;
}
while(deg &lt; 0){
    deg = deg + 360;
}
</code></pre>
<p>また、スイッチが押されたらその場所を基準としてそこからの角度を表示できるようにすると良いかもしれない。するとすれば<code>over</code>と<code>TIM3-&gt;CNT</code>をそれぞれ<code>0</code>にする必要がある。</p>
<p style="text-align:center"><img src="DevelopmentSTM32CubeIDE/InOut/../../resources/DevelopmentSTM32CubeIDE/InOut/InRotaryEncoder/deg.png" alt="deg.png" width="250"></p>  
<h3 id="参考-11"><a class="header" href="#参考-11">参考</a></h3>
<ul>
<li><a href="https://www.shujima.work/entry/2019/05/28/221629">【Nucleo入門】Nucleo-F401でエンコーダ読み取り(STM32CubeIDE、macOS版)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通信"><a class="header" href="#通信">通信</a></h1>
<p>他の機器と通信する方法について簡単に解説する。主に<code>UART</code>による通信について解説する。<br />
コントローラー側の<code>Arduino</code>との通信に使用するヘッダファイルなどの中身も軽く紹介する。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./uartReceive.html">UART通信(受信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./uartTransmit.html">UART通信(送信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./ConnectArduino.html">Arduinoとの通信</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart通信受信"><a class="header" href="#uart通信受信">UART通信(受信)</a></h1>
<h2 id="arduinoなどからのデータをuartを使用して受け取る"><a class="header" href="#arduinoなどからのデータをuartを使用して受け取る">ArduinoなどからのデータをUARTを使用して受け取る</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">/* USER CODE BEGIN 2 */
char getdata;
/* USER CODE END 2 */

/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    if(HAL_UART_Receive(&amp;huart1, &amp;getdata, 1, 10) == HAL_OK){
        printf("%x\r\n",getdata);
    }
}
/* USER CODE END 3 */
</code></pre>
<p>受け取ったデータを<code>printf</code>する。たとえば<code>Arduino</code>側でスイッチの値を送るとしたら<code>TeraTerm</code>の画面にはそのスイッチの値が表示されるだろう。</p>
<h3 id="参考-12"><a class="header" href="#参考-12">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/5a2c9e4fd35c261c4f3a">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(6) 　UARTを使ってみよう(2)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart通信送信"><a class="header" href="#uart通信送信">UART通信(送信)</a></h1>
<h2 id="arduinoなどにデータをuartを使用して送る"><a class="header" href="#arduinoなどにデータをuartを使用して送る">ArduinoなどにデータをUARTを使用して送る</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c">STprintf(&amp;huart2);
uint8_t i = 0;

/* USER CODE END 2 */

/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    HAL_UART_Transmit(&amp;huart1, &amp;i, 1, 10);
    printf("%d\r\n",i);
    HAL_Delay(250);
    i++;
}
</code></pre>
<p><code>HAL_UART_Transmit</code>でUARTを使用して<code>1Byte</code>のデータを送信する。<code>printf</code>で<code>i</code>の値を画面上に出力している。</p>
<h3 id="参考-13"><a class="header" href="#参考-13">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/76c812d35642a3c29aea">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(5) 　UARTを使ってみよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arduinoとの通信lib"><a class="header" href="#arduinoとの通信lib">Arduinoとの通信(lib)</a></h1>
<h2 id="keil-studioのserialctrlのようなライブラリの使用方法"><a class="header" href="#keil-studioのserialctrlのようなライブラリの使用方法">Keil StudioのSerialCtrlのようなライブラリの使用方法</a></h2>
<ol>
<li>
<p><code>UART_Arduinoライブラリ</code>の最新バージョンをダウンロード。</p>
<p><code>teams</code>等にある場合が多い。</p>
 <!-- または`github`上にある。[ここ](https://github.com/s2301089/development-F446RE/tree/main/lib/UART_Arduino)からダウンロード。   -->
</li>
<li>
<p>ダウンロードした<code>ヘッダファイル</code>を<code>プロジェクト</code>-<code>Core</code>-<code>Inc</code>に、<code>ソースファイル</code>を<code>プロジェクト</code>-<code>Core</code>-<code>Src</code>に移動。</p>
</li>
<li>
<p>使用したいソースファイル内等でヘッダファイルを<code>Include</code>する。</p>
</li>
<li>
<p>使用する<code>USART</code>を<code>.iocファイル</code>で設定しコードを生成。</p>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。</p>
</li>
<li>
<p>使用する関数を記述。</p>
</li>
</ol>
<blockquote>
<p>中には<code>printf</code>を使用する関数も含まれているため、<code>printf</code>を<code>UART通信</code>で使用できるようにしておく。<a href="DevelopmentSTM32CubeIDE/Connectability/../BasicContents/printfLibrary.html">参考</a></p>
</blockquote>
<p><strong>使用例1</strong><br />
<code>main.c</code></p>
<pre><code class="language-c">// 略
/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "USART_Arduino.h"
/* USER CODE END Includes */
// 中略
    /* USER CODE BEGIN 1 */
    setbuf(stdout,NULL);
    /* USER CODE END 1 */
// 中略
    /* USER CODE BEGIN 2 */
    getdata DATA;
    /* USER CODE END 2 */
// 中略
    /* USER CODE BEGIN WHILE */
    while (1)
    {
    /* USER CODE END WHILE */
    /* USER CODE BEGIN 3 */
        if(getData(&amp;huart1,&amp;DATA) == 0){
            AllShowP(DATA);
        }
    }
    /* USER CODE END 3 */
// 中略
    /* USER CODE BEGIN 4 */
    int _write(int file,char *ptr,int len){
        HAL_UART_Transmit(&amp;huart2, (uint8_t *)ptr, len, 10);
        return len;
    }
    /* USER CODE END 4 */
// 略
</code></pre>
<p>上記の使用例では、<code>printf</code>を<code>USART2</code>で使用できるようにし、<code>Arduino</code>との<code>UART通信</code>に<code>USART1</code>を使用している。また、<code>getdata</code>型の<code>DATA</code>という名前の構造体変数を宣言し、<code>getData関数</code>に引数として<code>DATA</code>のアドレスを渡している。</p>
<p><strong>使用例2</strong><br />
<code>main.c</code></p>
<pre><code class="language-c">// 略
/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "USART_Arduino.h"
#include "STprintf.h"
#include "manydef.h"
/* USER CODE END Includes */
// 略
    /* USER CODE BEGIN 2 */
    STprintf(&amp;huart2);
    unsigned int FAFcount = 0;
    /* USER CODE END 2 */
// 略
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        HAL_TIM_PWM_Start(&amp;htim3,TIMCH_3);
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
        getDataIT(&amp;huart1);
        printf("%d %d \r\n",FAF,FAFcount);
        if(FAF == 1){
            FAFcount = 0;
            AllShow(data);
            __HAL_TIM_SET_COMPARE(&amp;htim3,TIMCH_3,data.LY);
            HAL_GPIO_WritePin(GPIOxA, GPIO_Pin_0, 0);
        }else{
            FAFcount++;
            if(FAFcount &gt;= TIMEOUT_MAX * 10){
                __HAL_TIM_SET_COMPARE(&amp;htim3,TIMCH_3,0);
                HAL_GPIO_WritePin(GPIOxA, GPIO_Pin_0, 0);
                FAFcount = 0;
                printf("main timeout ");
                HAL_Delay(500);
            }
        }
    }
    /* USER CODE END 3 */
// 略
</code></pre>
<p>上記の使用例では、<code>printf</code>を<code>USART2</code>で使用できるようにし、<code>Arduino</code>との<code>UART通信</code>に<code>USART1</code>を使用している。あらかじめライブラリ内で宣言されている構造体<code>data</code>の<code>LY</code>の値に合わせて<code>LED</code>が点灯する。FAFとはデータを受信したかどうか記録するフラグ(変数)であり、フラグに合わせてタイムアウトの処理を行っている。タイムアウトの時間や回数などは他の処理の量によって変更した。</p>
<h3 id="各関数に関して"><a class="header" href="#各関数に関して">各関数に関して</a></h3>
<ul>
<li>getData関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>と<code>getdata*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>と受信したデータを入れる構造体変数のポインタ<code>getdata*</code>を渡す。</li>
<li><code>getData(&amp;huart1,DATA);</code></li>
<li>戻り値は、先頭データが<code>0xaf</code>であり、構造体に受信データが代入された場合は<code>0</code>、先頭データが<code>0xaf</code>でない場合は<code>-1</code>が返される。</li>
<li>受信にはポーリング方式を使用し、データを受信する関数。</li>
</ul>
</li>
<li>getDataIT関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>を渡す。</li>
<li><code>getDataIT(&amp;huart1);</code></li>
<li>使用には<code>Configuration</code>-<code>NVIC Setting</code>-<code>USART1 global interrupt</code>を<code>Enable</code>に設定する必要がある。</li>
<li>戻り値はなく、受信には割り込み使用し、データを受信する関数。</li>
</ul>
</li>
<li>AllShow関数
<ul>
<li>引数に<code>getdata</code>をもつ。構造体変数<code>getdata</code>を渡す。</li>
<li><code>AllShow(data);</code></li>
<li>戻り値はなく、構造体の中身を表示する関数。表示形式はアナログ値をもつスティックなどは整数3桁(空白埋め)で、ディジタル値をもつボタンなどは<code>0/1</code>で表示する。</li>
<li><code>printf</code>関数を使用するため、<code>printf</code>を使用するためのコードが必要になる。<a href="DevelopmentSTM32CubeIDE/Connectability/../BasicContents/printfLibrary.html">参考</a></li>
</ul>
</li>
<li>AllShowP関数
<ul>
<li>引数や戻り値は<code>AllShow</code>関数と同じである。</li>
<li>表示形式はスティックなどは<code>AllShow</code>関数と同じだが、ボタンなどは<code>AllShow</code>関数と異なり、押されているボタンを名前で表示する。送信側の<code>Arduino</code>のシリアルモニタと同じように表示される。</li>
</ul>
</li>
</ul>
<h3 id="内部で使用される各関数に関して"><a class="header" href="#内部で使用される各関数に関して">内部で使用される各関数に関して</a></h3>
<ul>
<li>RevAF関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>を渡す。</li>
<li><code>RevAF(huart);</code></li>
<li>戻り値は、受信したデータが先頭データ<code>0xaf</code>の場合は<code>0xaf</code>、そうでない場合は<code>0x00</code>を、そもそも受信していない場合は<code>0xff</code>を返す。</li>
<li>ポーリング方式の際に使用される関数。</li>
</ul>
</li>
<li>AddArray関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>と<code>uint8_t*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>と受信したデータを入れる配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li><code>AddArray(huart,Rdata);</code></li>
<li>戻り値はなく、受信データの総数になるまで受信したデータを配列に順番に代入する。</li>
<li>ポーリング方式の際に使用される関数。</li>
</ul>
</li>
<li>HAL_UART_RxCpltCallback関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。この関数は受信割り込みでデータを受信した時に自動的に実行される。</li>
<li>戻り値はなく、<code>FAF</code>を揚げデータを受信したことを表す。また、<code>getData</code>関数の内部処理のようなことを行う。</li>
<li>割り込みを使用した際に使用される関数。</li>
</ul>
</li>
<li>ChSUM関数
<ul>
<li>引数に<code>uint8_t*</code>をもつ。受信したデータが入った配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li>配列の最後のデータが終端データ<code>0xed</code>であるか確認し、終端データである場合、チェックサムを行う。</li>
<li>チェックサムとは、各スティックと各ボタンのデータの総和が送信側で計算された総和と一致しているか確認すること。送信側の計算結果も受信データに含まれている。</li>
<li>戻り値は、総和が一致している場合は<code>0xed</code>、そうでない場合は<code>0x00</code>、配列の最後のデータが正しくない場合は<code>0xff</code>を返す。</li>
<li>ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
<li>AddStruct関数
<ul>
<li>引数に<code>getdata*</code>と<code>uint8_t*</code>をもち、データを格納する構造体変数のポインタ<code>getdata*</code>と受信データが入ってる配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li><code>AddStruct(&amp;data,AIdata);</code></li>
<li>配列の値から構造体の各要素にデータを代入する。</li>
<li>戻り値はなく、ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
<li>StructInit関数
<ul>
<li>引数に<code>getdata*</code>をもつ。データを格納する構造体変数のポインタ<code>getdata*</code>を渡す。</li>
<li><code>StructInit(&amp;data);</code></li>
<li>構造体の各要素を初期化する。<code>LX</code>,<code>LY</code>,<code>RX</code>,<code>RY</code>スティックは<code>0x80</code>に、<code>L2</code>,<code>R2</code>スティックは<code>0x00</code>に、各ボタンは<code>0</code>に初期化される。</li>
<li>戻り値はなく、ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
