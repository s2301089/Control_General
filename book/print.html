<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control_General</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Control_General</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前提条件等"><a class="header" href="#前提条件等">前提条件等</a></h1>
<p>筆者の制御に関するお勉強・開発のHome<br />
プログラムの使用言語は基本的に<code>C言語</code>、<code>C++</code>である。一部、他の言語の知識が混ざる可能性がある。<br />
環境構築等はすでに済んでいるものとし、コードの内容のみになる場合がある。筆者と異なるOSを使用する場合は各自で環境に合わせて対応すること。<br />
各開発などのリポジトリは各ページに掲載していることもあるが、あくまで参考程度にしかならない。<br />
一部に自作のヘッダファイルなどを使用する場合がある。その場合は、そのファイルの中身などを簡単に説明する記事を作るように心掛ける。<br />
<strong>結局は自分で調べ、データシートなどを確認することがとても大事である。</strong></p>
<hr />
<h2 id="使用環境"><a class="header" href="#使用環境">使用環境</a></h2>
<ul>
<li>Windows 11 Home</li>
<li>Ubuntu 22.04 LTS</li>
</ul>
<h2 id="使用中使用予定のマイコン一覧"><a class="header" href="#使用中使用予定のマイコン一覧">使用中(使用予定)のマイコン一覧</a></h2>
<ul>
<li><a href="https://akizukidenshi.com/catalog/g/g110176/">NUCLEO-F446RE</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g110172/">NUCLEO-F303K8</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g107385/">Arduino Uno Rev3</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g116132/">Raspberry Pi Pico</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g117215/">(ATOM Matrix)</a></li>
<li><a href="https://akizukidenshi.com/catalog/g/g115674/">(ESP32-WROVER-E)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一覧"><a class="header" href="#一覧">一覧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitコマンドの使い方"><a class="header" href="#gitコマンドの使い方">gitコマンドの使い方</a></h1>
<p><code>git</code>とはバージョン管理ツールである。誰がいつどの部分を変更したのかを細かく記録できる。プログラムなどの開発では、うまく行ったときとそうでないときの違いなどを確認しやすくなる。<br />
<code>git</code>のリポジトリ(管理されているフォルダ)をwebから閲覧・編集可能にしたサービスが<code>GitHub</code>。<code>git</code>と<code>GitHub</code>は全くの別物である。</p>
<h2 id="導入"><a class="header" href="#導入">導入</a></h2>
<ul>
<li>
<p><code>git</code>のダウンロード
<a href="https://git-scm.com/downloads/win">Download for Windows</a><br />
基本的に<code>Click here to download</code>をクリックし、インストーラーをダウンロードする。</p>
</li>
<li>
<p>ダウンロードしたインストーラー<code>Git-x.xx.x-64-bit.exe</code>をクリックし、インストーラーを起動する。
基本的に<code>Next</code>を選択する。</p>
</li>
<li>
<p>インストールが完了したら<code>Git Bash</code>を起動する。
デスクトップのショートカット、あるいは、スタートから起動する。</p>
</li>
<li>
<p><code>git</code>のバージョンを確認し、インストールできていることを確認する。</p>
<pre><code class="language-bash : Git Bash">$ git --version
git version 2.44.0.windows.1 # 例
</code></pre>
</li>
<li>
<p><code>GitHub</code>への登録
<a href="https://github.com/">GitHub</a><br />
すでに<code>GitHub</code>アカウントがある人は右上の<code>Sign in</code>を選択しログインする。<br />
アカウントがない人は<code>Sign up</code>を選択し、新規作成を行う。</p>
<ul>
<li><code>Email</code> : メールアドレスを入力
学校のメールアドレスでも良いが、卒業時などに別のメールアドレスに変更しなければならない。</li>
<li><code>Password</code> : 15文字以上、または、数字と小文字を含む8文字以上</li>
<li><code>Username</code> : ユーザー名。半角英数字</li>
<li><code>Your Country/Region</code> : 国と地域<code>Japan</code></li>
<li><code>Email preferemces</code> : お知らせメールを受け取るかどうか(自由)
<code>Create account</code>で作成完了(なはず)</li>
</ul>
</li>
</ul>
<h2 id="sshの設定"><a class="header" href="#sshの設定">SSHの設定</a></h2>
<p>学内LANなどからサーバーと通信を行うためには、<code>SSH</code>による認証を使用しなければならない。</p>
<ul>
<li>
<p><code>SSH</code>鍵を作成する。</p>
</li>
<li>
<p><code>~/.ssh/</code>に移動する。ない場合は作成する。</p>
<pre><code class="language-bash : Git Bash">$ ls -a ~ | grep .ssh
.ssh/ # ある
# ない場合 $ mkdir ~/.ssh
$ cd ~/.ssh/
</code></pre>
</li>
<li>
<p>すでに<code>SSH</code>鍵が作られているか確認する。</p>
<pre><code class="language-bash : Git Bash">$ ls
# なにも表示されない、または、known_hostsのみならok
</code></pre>
</li>
<li>
<p><code>ssh-keygen.exe</code>で<code>SSH</code>鍵を作成する。</p>
<pre><code class="language-bash : Git Bash">$ ssh-keygen -t rsa -C [email@email.com] -f [id_rsa_username]
# email@email.com は GitHub に登録したメールアドレス
# id_rsa_username は 出力ファイル名(自由)
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): # SSH鍵のパスワード Enterでパスワードなし
Enter same passphrase again: # パスワードの再入力 Enter
Your identification has been saved in id_rsa_username
Your public key has been saved in id_rsa_username.pub
The key fingerprint is:
SHA256:------ email@email.com
The key's randomart image is:
---
</code></pre>
</li>
<li>
<p><code>ssh</code>鍵が生成される</p>
</li>
<li>
<p>公開鍵と秘密鍵の両方が生成されていることを確認。</p>
<pre><code class="language-bash : Git Bash">$ ls
id_rsa_username       known_hosts
id_rsa_username.pub 
</code></pre>
</li>
<li>
<p><code>id_rsa_username.pub</code>の内容をコピーする。クリップボードにコピーする。</p>
<pre><code class="language-bash : Git Bash">cat id_rsa_username.pub | clip
</code></pre>
</li>
<li>
<p><code>GitHub</code>に登録する
<a href="https://github.com/">GitHub</a></p>
<ul>
<li><code>アイコン</code> - <code>Settings</code> - <code>Access</code> - <code>SSH and GPG keys</code> - <code>SSH Keys</code></li>
<li><code>New SSH key</code><br />
<code>Title</code>は鍵の名前を設定する。パソコン名や学校名などにしておくとわかりやすい。<br />
<code>Key type</code>は<code>Authentication Key</code>に設定する。<br />
<code>Key</code>に先ほどコピーした鍵をペーストする。</li>
<li><code>Add SSH key</code>で<code>SSH</code>鍵を登録する。</li>
</ul>
</li>
<li>
<p><code>SSH</code>の設定</p>
</li>
<li>
<p><code>~/.ssh/config</code>を開く(なければ作成する)</p>
<pre><code class="language-bash : Git Bash">$ ls
config # ある
# ない場合 $ touch config
$ code config
</code></pre>
</li>
<li>
<p>アカウントと<code>SSH</code>鍵を紐づける設定</p>
<pre><code class="language-config : config">Host github.com
    HostName github.com
    IdentityFile /C/Users/user_name/.ssh/id_rsa_username
    User git
    Port 22
    TCPKeepAlive yes
    IdentitiesOnly yes
</code></pre>
</li>
<li>
<p><code>SSH</code>の確認<br />
通信ができるかどうか確認する</p>
<pre><code class="language-bash : Git Bash">$ ssh -T github.com
Hi username! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>
</li>
</ul>
<h2 id="gitコマンドの基本"><a class="header" href="#gitコマンドの基本">gitコマンドの基本</a></h2>
<h3 id="clone"><a class="header" href="#clone">clone</a></h3>
<p>リモート(<code>Git</code>のサーバー)からリポジトリをローカル(自分の作業環境)に複製する。</p>
<pre><code class="language-bash : Git Bash">$ git clone [remote URL]
# 実行するディレクトリに注意
</code></pre>
<p>実行したディレクトリにそのリポジトリが複製される。<code>[remote URL]</code>は<code>GitHub</code>から確認する。<br />
<a href="https://github.com/">GitHub</a>からcloneしたいリポジトリのページまで移動する。緑色の<code>&lt;&gt;Code</code>を押し<code>Local</code>の<code>Clone</code>の<code>SSH</code>からコピーする。</p>
<h3 id="add"><a class="header" href="#add">add</a></h3>
<p>ローカルで変更したファイルなどをリモートにあげるファイルを選択する。<br />
コミットに含めるファイルを選択する。</p>
<pre><code class="language-bash : Git Bash">$ git add [ファイル名1] [ファイル名2] …
# ファイル名(フォルダ名)は何個でも書けるはず…
</code></pre>
<h3 id="commit"><a class="header" href="#commit">commit</a></h3>
<p>コミットを作成する。<code>add</code>したファイルをひとまとまりにする。</p>
<pre><code class="language-bash : Git Bash">$ git commit -m "[コミットメッセージ]"
# コミットメッセージをつける
</code></pre>
<p>コミットメッセージには何を更新したのかなどの内容を書いておくとよい。</p>
<blockquote>
<p><code>add</code>：ファイルの新規作成や新規追加など<br />
<code>update</code>：ファイルの中身の更新など<br />
<code>fixed</code>、<code>fix</code>：バグの修正など<br />
<code>style</code>：動作に問題のない部分の修正、ドキュメントやインデントの修正など<br />
例
"fixed #3"、"update; add to receive controller;"<br />
コミットメッセージは日本語でもよい(基本英語)。(部内であれば日本語でも大丈夫)</p>
</blockquote>
<h3 id="push"><a class="header" href="#push">push</a></h3>
<p>作成したコミットをリモートに反映させる。</p>
<pre><code class="language-bash : Git Bash">$ git push origin main
# mainブランチにpushする
</code></pre>
<h3 id="更新されたファイルなどがあるか確認"><a class="header" href="#更新されたファイルなどがあるか確認">更新されたファイルなどがあるか確認</a></h3>
<pre><code class="language-bash : Git Bash">$ git status
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
---
</code></pre>
<p>現在のリポジトリで更新されたファイルがあるかどうか、確認できる。</p>
<h3 id="リモートの変更をもってくる"><a class="header" href="#リモートの変更をもってくる">リモートの変更をもってくる</a></h3>
<p>他の端末などで変更を加え、リモートに反映させた。手元には反映前のコードなどがある。というときにわざわざディレクトリを削除してもう一度<code>clone</code>するのはめんどくさい。</p>
<pre><code class="language-bash : Git Bash">$ git pull
# $ git pull origin [branch名] でpullするブランチを指定できる
</code></pre>
<p>とリモートの変更を反映させることができる。</p>
<pre><code class="language-bash : Git Bash">git pull origin main
</code></pre>
<p>と同じことをしていて、リモートのmainブランチから<code>fetch</code>(変更をもってくるだけ)と<code>merge</code>(変更を反映させる)を同時に行う。<code>merge</code>するときにローカルにリモートにはない変更があった場合は、手動で<code>merge</code>作業を行う必要がある。</p>
<h2 id="branchを分ける"><a class="header" href="#branchを分ける">branchを分ける</a></h2>
<p>普段はおそらくmainブランチ、または、masterブランチを使用していると思われるが、開発用のブランチmainと更新用(リリースごと)のブランチdeveに分けておきたいとする。mainブランチは日々の開発によりたくさんの更新が入りどのコミットでうまくいったのかがわからないこともある。ブランチは分けずにタグを作成して、そのときのコミットに戻れるという機能もあるがそれはbranchの次に紹介する。</p>
<blockquote>
<p>開発用は<code>development</code>とかで確実に動くものは<code>main</code>に反映させるなどもあり。</p>
</blockquote>
<h3 id="ブランチを作成"><a class="header" href="#ブランチを作成">ブランチを作成</a></h3>
<p>まずはブランチを作成する。</p>
<pre><code class="language-bash : Git Bash">git branch deve
</code></pre>
<p><code>deve</code>という名前のブランチがローカルに作成された。</p>
<pre><code class="language-bash : Git Bash">$ git branch
* main
  deve
</code></pre>
<p>現在ローカルにあるブランチの一覧を表示できる。</p>
<h3 id="ブランチに移動する"><a class="header" href="#ブランチに移動する">ブランチに移動する</a></h3>
<p>ブランチを作成したらそのブランチに移動する。</p>
<pre><code class="language-bash : Git Bash">git checkout [ブランチ名]
</code></pre>
<h3 id="addしたりcommitしたり"><a class="header" href="#addしたりcommitしたり">addしたりcommitしたり</a></h3>
<p>あとは変更したファイルをaddしたりcommitしたりしても問題ない。</p>
<pre><code class="language-bash : Git Bash">$ git push origin [ブランチ名]
# origin で指定しないとpushできないことがある
</code></pre>
<h3 id="ブランチを他のブランチと同じバージョンまで持ってくる"><a class="header" href="#ブランチを他のブランチと同じバージョンまで持ってくる">ブランチを他のブランチと同じバージョンまで持ってくる</a></h3>
<p>mainブランチだけ先に進み、deveブランチが遅れている場合、deveブランチにmainブランチの状態にしたいなどということもあると思われる。そんなときにいちいちmainブランチからdeveブランチにコピペするのは面倒くさい。そんなときに<code>merge</code>を使用する。<br />
進めたいブランチに<code>checkout</code>し、</p>
<pre><code class="language-bash : Git Bash">git merge [進んでいるブランチ名]
</code></pre>
<p>を実行する。deveブランチをmainブランチと同じ状態にしたい場合は、</p>
<pre><code class="language-bash : Git Bash">git checkout deve
git merge main
</code></pre>
<p>を実行することでdeveブランチにmainブランチの変更を反映させることができる。<br />
このあとにdeveブランチにpushし、リモートにも反映させる。</p>
<h3 id="ブランチの削除"><a class="header" href="#ブランチの削除">ブランチの削除</a></h3>
<p>ブランチが要らなくなったときに削除できるように。</p>
<pre><code class="language-bash : Git Bash">git branch -d [ブランチ名]
</code></pre>
<p>でブランチを削除できる。これでローカルのブランチが削除された。</p>
<pre><code class="language-bash : Git Bash">git push origin --delete [ブランチ名]
</code></pre>
<p>でリモートのブランチも削除することができる。</p>
<h3 id="確認"><a class="header" href="#確認">確認</a></h3>
<p>現在ローカルにあるブランチを確認するには</p>
<pre><code class="language-bash : Git Bash">git branch
</code></pre>
<p>を使用する。<br />
リモートにあるブランチも確認するには</p>
<pre><code class="language-bash : Git Bash">git branch -r
</code></pre>
<p>を使用する。</p>
<h2 id="tag"><a class="header" href="#tag">tag</a></h2>
<p>特定のバージョンに戻りたい(リリースバージョンとか)というときにリリースを作成するという事もできるがそれでは検索などに引っかかってしまう。それが嫌だという場合はtagを作成し、そのタグに戻ればよい。</p>
<h3 id="tagの作成とpush"><a class="header" href="#tagの作成とpush">tagの作成とpush</a></h3>
<p>タグを作成する前に変更などはすべてリモートに反映させておくとよい。</p>
<pre><code class="language-bash : Git Bash">git tag -a [タグ名] -m "[タグのメッセージ]"
</code></pre>
<p>これでローカルにtagを作成する。ローカルのcommitにtagがつけられる(と思われる)。</p>
<pre><code class="language-bash : Git Bash">git push origin [タグ名]
</code></pre>
<p>これにより、タグを作成し、作成したタグをリモートに反映することができる。</p>
<h3 id="tagの確認"><a class="header" href="#tagの確認">tagの確認</a></h3>
<pre><code class="language-bash : Git Bash">git tag
</code></pre>
<p>でローカルにあるタグを確認できる。</p>
<h3 id="tagの削除"><a class="header" href="#tagの削除">tagの削除</a></h3>
<pre><code class="language-bash : Git Bash">git tag -d [タグ名]
</code></pre>
<p>でローカルにあるタグを削除する。</p>
<pre><code class="language-bash : Git Bash">git push origin --delete [タグ名]
</code></pre>
<p>でリモートにあるタグを削除する。</p>
<h4 id="参考"><a class="header" href="#参考">参考</a></h4>
<ul>
<li>授業・講座</li>
<li><a href="https://qiita.com/chihiro/items/e178e45a7fd5a2fb4599#git-branch---no-color">git branch コマンド</a></li>
<li><a href="https://backlog.com/ja/git-tutorial/">サル先生のGit入門</a></li>
<li><a href="https://youtu.be/LDOR5HfI_sQ?si=grgKMmUMKT4dgnn-">【Git入門】Git + Github使い方入門講座🐒Gitの仕組みや使い方を完全解説！パーフェクトGit入門！</a></li>
<li><a href="https://youtu.be/2mehreEA7yc?si=5BQeVtQgHnAOc_l_">GitHubの使い方を解説！ファイルの作成方法、ブランチの使い方が分かる！</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モーターのpwm制御"><a class="header" href="#モーターのpwm制御">モーターのPWM制御</a></h1>
<h2 id="pwmとは"><a class="header" href="#pwmとは">PWMとは</a></h2>
<p><code>PWM</code>とは、<code>Pulse Width Modulation</code>の略で<code>パルス幅変調</code>という。一定周期の中で出力が<code>HIGH</code>の長さと<code>LOW</code>の長さ比(デューティー比)で出力が決まる。</p>
<blockquote>
<p>出力が<code>5V</code>でデューティー比が<code>25%</code>であれば、出力は<code>1.25V</code>になる。出力電圧は以下の式で求められる。<br />
<code>(出力電圧) = (最大電圧) × (デューティー比)</code><br />
そのため、デューティー比が小さすぎると素子によってはデューティー比<code>0％</code>とあまり変わらない結果が得られるものもある。各素子の最低電圧などを確認すること。</p>
</blockquote>
<h2 id="モーターを回す"><a class="header" href="#モーターを回す">モーターを回す</a></h2>
<p>回路的には以下のようになっている。<br />
<img src="BasicContents/../resources/BasicContents/motor/motor_road.drawio.png" alt="motor_road.drawio.png" /><br />
モタドラICの動作電圧が<code>12V</code>でマイコンからの信号の電圧が<code>5V</code>か<code>3.3V</code>なので電圧を上げる必要がある。それをフォトカプラ基板で信号のやり取りを行っている。また、<code>PWM</code>の周期を<code>83[μs]</code>に設定する。これはモタドラICの周波数が<code>12[kHz]</code>あたりがいいらしいからだ(モタドラIC<code>HIP4081AIPZ</code>)。</p>
<h2 id="フォトカプラによる動作の違い"><a class="header" href="#フォトカプラによる動作の違い">フォトカプラによる動作の違い</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォトカプラ</th><th style="text-align: center">部品</th><th style="text-align: center">用途</th><th style="text-align: center">向き</th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/1611038?gb=a">'TLP621'</a></td><td style="text-align: center"><img src="BasicContents/../resources//BasicContents/motor/pic_TLP621.JPG" alt="pic_TLP621.JPG" /></td><td style="text-align: center">ディジタルの変換</td><td style="text-align: center">左下にある◯がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/1718031?cm_mmc=JP-PLA-DS3A-_-google-_-PLA_JP_JP_ePmax_Prio1-_--_-&amp;matchtype=&amp;&amp;campaignid=20858944244&amp;gad_source=1&amp;gclid=CjwKCAiArKW-BhAzEiwAZhWsIC59PvjUU27b9lFqq5lPOYafc83XY63O_NRmTJ4k13gT-4t-ofMuexoCSNoQAvD_BwE&amp;gclsrc=aw.ds">'TLP521-2'</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_TLP521-2.JPG" alt="pic_TLP521-2.JPG" /></td><td style="text-align: center">ディジタルの変換×2</td><td style="text-align: center">左下にある◯がマイコン側または、角が削れている方がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/2347111?srsltid=AfmBOop1mbTNh_2S3L3LVPv-URRDD3y03iuBuspMm1w5xkRcWY2EgoUm">'PS9513'</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_PS9513.JPG" alt="pic_PS9513.JPG" /></td><td style="text-align: center">PWMの変換</td><td style="text-align: center">左下にある◯がマイコン側</td></tr>
<tr><td style="text-align: center"><a href="https://jp.rs-online.com/web/p/optocouplers/8851279?srsltid=AfmBOoqXYwz-_Yaf1EzdvjIdm6IBj3ft_dYQmsY4QKocpl6aMEDGDWGd">'TLP250H'</a></td><td style="text-align: center"><img src="BasicContents/../resources/BasicContents/motor/pic_TLP250H.JPG" alt="pic_TLP250H.JPG" /></td><td style="text-align: center">PWMの変換</td><td style="text-align: center">左下にある◯がマイコン側または、角が削れている方がマイコン側</td></tr>
</tbody></table>
</div>
<p><strong>注意点</strong></p>
<ul>
<li><code>TLP521-2</code>はPWMの変換と同じような大きさだが内部の配線では<code>TLP621</code>が2個あるような配置になっている。PWMの変換には使用できないので注意。</li>
<li><code>PS9513</code>を標準とすると<code>TLP250H</code>は出力が反転している。例えば、入力に<code>0</code>が入っている場合<code>PS9513</code>では出力が<code>0</code>だが、<code>TLP250H</code>では<code>255</code>が出力される。使用するフォトカプラに合わせてコードを書き換える必要がある。</li>
</ul>
<h2 id="左回りと右回り正転と反転"><a class="header" href="#左回りと右回り正転と反転">左回りと右回り(正転と反転)</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">PWM側フォトカプラ</th><th style="text-align: center">Digi</th><th style="text-align: center">LOWの時のデューティー比</th><th style="text-align: center">HIGHの時のデューティー比</th><th style="text-align: center">回転方向</th><th style="text-align: center">出力波形部分</th></tr></thead><tbody>
<tr><td style="text-align: center">PS9513</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">左回り</td><td style="text-align: center">①</td></tr>
<tr><td style="text-align: center">PS9513</td><td style="text-align: center">1</td><td style="text-align: center">255</td><td style="text-align: center">0</td><td style="text-align: center">右回り</td><td style="text-align: center">②</td></tr>
<tr><td style="text-align: center">TLP250H</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">0</td><td style="text-align: center">左回り</td><td style="text-align: center">②</td></tr>
<tr><td style="text-align: center">TLP250H</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">255</td><td style="text-align: center">右回り</td><td style="text-align: center">①</td></tr>
</tbody></table>
</div>
<p><code>出力波形</code><br />
<img src="BasicContents/../resources/BasicContents/motor/PWM_modu.png" alt="PWM_modu.png" /></p>
<h3 id="参考-1"><a class="header" href="#参考-1">参考</a></h3>
<ul>
<li><a href="https://deviceplus.jp/arduino/arduino_f04/">Arduino（アルディーノ）電子工作の基本④ LEDの明るさを調節する</a></li>
<li><a href="https://moons.link/post-632/">STM32 HALを使ってPWM出力してみる</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ｺﾝﾄﾛｰﾗｰで送受信するデータ"><a class="header" href="#ｺﾝﾄﾛｰﾗｰで送受信するデータ">ｺﾝﾄﾛｰﾗｰで送受信するデータ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platformioの導入"><a class="header" href="#platformioの導入">PlatformIOの導入</a></h1>
<p>2025Team_Bは<code>Keil Studio</code>を使用した制御プログラムの作成を辞め、他の開発環境への移行を考えている。Mbedのサポート終了が宣言されたからである。<a href="https://os.mbed.com/blog/entry/Important-Update-on-Mbed/">'記事'</a><br />
<code>PlatformIO</code>は<code>ArduinoIDE</code>での書き方や<code>Mbed OS</code>での書き方などいろいろな書き方ができる。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentPlatformIO/./InstallPlatformIO.html">PlatformIOの入れ方</a></li>
<li><a href="DevelopmentPlatformIO/./FrameworkArduino/FrameworkArduinoHome.html">Arduinoで書く</a>
<ul>
<li><a href="DevelopmentPlatformIO/./FrameworkArduino/MakeProjectLchika.html">プロジェクトの作成とLチカ</a></li>
<li><a href="DevelopmentPlatformIO/./FrameworkArduino/SerialPrint.html">シリアルモニタに出力</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-ioを入れる"><a class="header" href="#platform-ioを入れる">Platform IOを入れる</a></h1>
<p>そしてこれは<code>VSCode</code>の拡張機能なので比較的導入が簡単なものである。
この拡張機能を使用して試しにコードを書き込むまでの記録。</p>
<h2 id="学内lanでは極力ダウンロードなどはしないようにしよう"><a class="header" href="#学内lanでは極力ダウンロードなどはしないようにしよう">学内LANでは極力ダウンロードなどはしないようにしよう</a></h2>
<blockquote>
<p>学内LANで<code>PlatformIO</code>のセッティングを行うためには<code>VSCode</code>自体のプロキシ設定が必要になる。<br />
<code>Ctrl + ,</code>で設定を開き、設定の検索バーで<code>proxy</code>と入力。<code>Http: Proxy(すべてのプロファイルに適用)</code>を探し、プロキシサーバーを入力する欄に学内LANのプロキシサーバー(<code>http://サーバーアドレス:ポート番号</code>)を入力し、保存し終わったら<code>VSCode</code>の再起動を行う。</p>
</blockquote>
<p><code>VSCode</code>で拡張機能のマーケットプレイスで、<code>PlatformIO IDE</code>をインストールする。<code>platformio.platformio-ide</code>これを検索バーに入力するか、<code>platform</code>とか検索する。<a href="https://marketplace.visualstudio.com/items/?itemName=platformio.platformio-ide">'Marketplace'</a></p>
<p>インストール中に<code>PlatformIO: Can not find working Python 3.6+ Interpreter. Please install the latest Python 3 and restart VSCode</code>こんな表示がでてくるかもしれない。これは<code>Python 3.6</code>以上が見つかりませんって言われているだけ。<code>Python</code>をインストールしていない人は<code>Install Python</code>を押して<a href="https://www.python.org/downloads/">'site'</a>からWindows用をダウンロードする。もうインストールしてある人は<code>I have Python</code>てきなところを押せばいいと思われ。僕はインストールしてなかったからインストールする。</p>
<blockquote>
<p>追記：<code>PlatformIO</code>は<code>Python3.11</code>以下で動作するみたい<br />
siteから<code>python</code>をインストールする場合は<code>Python Releases for Windows</code>の下の方にある<code>Python 3.11.9 - April 2, 2024</code>などをダウンロードしてインストールしよう。</p>
</blockquote>
<p><code>Python</code>のインストーラーをダウンロードしたら、Pythonのインストーラーを実行。下のチェックボックス欄の<code>Add Python.exe to PATH</code>にチェックを入れる。<code>Use admin privileges when installing py.exe</code>のチェックは管理者権限ですべてのユーザーにインストールするみたいな項目だから、チェックしてなくて問題ない。チェックが終わったら<code>Install Now</code>を押してインストールする。<br />
<code>Setup was Successful</code>がでたら<code>Close</code>を押してもよいけど、<code>Disable path length limit</code>っていう項目が残っている。これはパスの長さの制限をなくしますか？っていう項目だから押しておけば今後何も考えなくていい。押さなくても別に問題はないかも。(僕は押した)<br />
そしたら<code>VSCode</code>を再起動してほかのインストールが終わるのを待つ。</p>
<h3 id="参考-2"><a class="header" href="#参考-2">参考</a></h3>
<ul>
<li><a href="https://tech.nri-net.com/entry/arduino_with_vscode">ArduinoをVSCodeで開発する【PlatformIO】</a></li>
<li><a href="https://qiita.com/cointoss1973/items/b3c84daeed90fd183501">Visual Studio Code に Proxy を設定する方法</a></li>
<li><a href="https://www.python.jp/install/windows/install.html">Windows版Pythonのインストール</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frameworkでmbedosを選択したとき"><a class="header" href="#frameworkでmbedosを選択したとき">FrameworkでMbedOSを選択したとき</a></h1>
<p>基本的なことは<code>Keil Studio</code>と同じ。ただし、<code>MbedOS6</code>であることに注意。(おそらく普段は<code>MbedOS2</code>を使用していると思われる)</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentPlatformIO/FrameworkMbedOS/./LchikaPrint.html">Lチカと変数の表示</a></li>
<li><a href="DevelopmentPlatformIO/FrameworkMbedOS/./outPwm.html">PWMを出力する</a></li>
<li><a href="DevelopmentPlatformIO/FrameworkMbedOS/./readAnalogResi.html">可変抵抗の値を読む</a></li>
<li><a href="DevelopmentPlatformIO/FrameworkMbedOS/./canUsePrintFloat.html">%fできるようにする</a></li>
<li><a href="DevelopmentPlatformIO/FrameworkMbedOS/./howToUseOs6Sample.html">SerialCtrl(OS6 sample)</a></li>
</ul>
<h2 id="名前空間mbed"><a class="header" href="#名前空間mbed">名前空間<code>mbed</code></a></h2>
<h3 id="mbedprintf"><a class="header" href="#mbedprintf"><code>mbed::printf(...)</code></a></h3>
<ul>
<li>シリアル通信で文字列などを送信する関数</li>
<li>デフォルトでは<code>PC</code>とボーレート<code>9600[bps]</code>で通信を行う</li>
<li><code>stdio.h</code>の<code>printf()</code>である</li>
</ul>
<pre><code class="language-cpp : main.cpp">printf("HelloWorld.\n");
</code></pre>
<h3 id="mbeddigitaloutクラス"><a class="header" href="#mbeddigitaloutクラス"><code>mbed::DigitalOut</code>クラス</a></h3>
<h4 id="mbeddigitaloutpin"><a class="header" href="#mbeddigitaloutpin"><code>mbed::DigitalOut::(pin)</code></a></h4>
<ul>
<li>ディジタル出力を行うクラス</li>
<li>使用する<code>GPIO</code>ピンを指定する</li>
<li>引数
<ul>
<li><code>pin</code></li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// PA_0 を出力ピンとしてインスタンスを作成
DigitalOut led(PA_0);
</code></pre>
<h4 id="mbeddigitaloutwritevalue"><a class="header" href="#mbeddigitaloutwritevalue"><code>mbed::DigitalOut::write(value)</code></a></h4>
<ul>
<li>ディジタル出力を行う関数</li>
<li>引数
<ul>
<li><code>value</code> (<code>1</code>/<code>0</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// ledのピンを1(HIGH)に指定
led.write(1);
</code></pre>
<h4 id="mbeddigitaloutreadvoid"><a class="header" href="#mbeddigitaloutreadvoid"><code>mbed::DigitalOut::read(void)</code></a></h4>
<ul>
<li>現在のディジタル値を取得する関数</li>
<li>引数
<ul>
<li>なし</li>
</ul>
</li>
<li>戻り値
<ul>
<li>ディジタル値 (<code>1</code>/<code>0</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// ledの値をled_valueに代入
bool led_value = led.read();
</code></pre>
<h3 id="mbeddigitalinクラス"><a class="header" href="#mbeddigitalinクラス"><code>mbed::DigitalIn</code>クラス</a></h3>
<h4 id="mbeddigitalinpin"><a class="header" href="#mbeddigitalinpin"><code>mbed::DigitalIn::(pin)</code></a></h4>
<ul>
<li>ディジタル入力を行うクラス</li>
<li>引数
<ul>
<li><code>pin</code></li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// PA_1 を入力ピンとしてインスタンスを作成
DigitalIn sw(PA_1);
</code></pre>
<h4 id="mbeddigitalinreadvoid"><a class="header" href="#mbeddigitalinreadvoid"><code>mbed::DigitalIn::read(void)</code></a></h4>
<ul>
<li>ディジタル値を取得する関数</li>
<li>引数
<ul>
<li>なし</li>
</ul>
</li>
<li>戻り値
<ul>
<li>ディジタル値 (<code>1</code>/<code>0</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// swの値を変数sw_valueに代入
bool sw_value = sw.read();
</code></pre>
<h3 id="mbedpwmoutクラス"><a class="header" href="#mbedpwmoutクラス"><code>mbed::PwmOut</code>クラス</a></h3>
<h4 id="mbedpwmoutpin"><a class="header" href="#mbedpwmoutpin"><code>mbed::PwmOut::(pin)</code></a></h4>
<ul>
<li><code>PWM</code>波形の出力を行うクラス</li>
<li>引数
<ul>
<li><code>pin</code></li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// PB_0 をPWM出力ピンとしてインスタンスを作成
PWMOut moter(PB_0);
</code></pre>
<h4 id="mbedpwmoutperiod_ustime"><a class="header" href="#mbedpwmoutperiod_ustime"><code>mbed::PwmOut::period_us(time)</code></a></h4>
<ul>
<li><code>PWM</code>の周期を設定する関数</li>
<li>引数
<ul>
<li><code>time</code></li>
<li>単位は<code>[us]</code></li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// moterのPWM周期を83[us]に設定
moter.period(83);
</code></pre>
<h4 id="mbedpwmoutwritevalue"><a class="header" href="#mbedpwmoutwritevalue"><code>mbed::PwmOut::write(value)</code></a></h4>
<ul>
<li><code>PWM</code>波形を出力する関数</li>
<li>引数
<ul>
<li><code>value</code>
<ul>
<li>範囲は<code>0</code>~<code>1</code>(少数)</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// Duty比25％に指定
moter.write(0.25);
</code></pre>
<h3 id="mbedanaloginクラス"><a class="header" href="#mbedanaloginクラス"><code>mbed::AnalogIn</code>クラス</a></h3>
<h4 id="mbedanaloginpin"><a class="header" href="#mbedanaloginpin"><code>mbed::AnalogIn::(pin)</code></a></h4>
<ul>
<li>アナログ入力を行うクラス</li>
<li>引数
<ul>
<li><code>pin</code></li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// PA_4 をアナログ入力ピンとしてインスタンスを作成
AnalogIn variable_resister(PA_4);
</code></pre>
<h4 id="mbedanaloginreadvoid"><a class="header" href="#mbedanaloginreadvoid"><code>mbed::AnalogIn::read(void)</code></a></h4>
<ul>
<li><code>AD</code>値を取得する関数</li>
<li>戻り値
<ul>
<li><code>AD</code>値</li>
<li>範囲は<code>0</code>~<code>1</code>(少数)</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// variable_resisterのAD値を取得する
double variable_resister_value = variable_resister.read();
</code></pre>
<h2 id="名前空間mbedthisthread"><a class="header" href="#名前空間mbedthisthread">名前空間<code>mbed::ThisThread</code></a></h2>
<h3 id="mbedthisthreadsleep_fortimems"><a class="header" href="#mbedthisthreadsleep_fortimems"><code>mbed::ThisThread::sleep_for(timems)</code></a></h3>
<ul>
<li>指定した時間処理を停止する関数</li>
<li>引数
<ul>
<li><code>timems</code>
<ul>
<li><code>ms</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp : main.cpp">// 250[ms]間処理を停止する
sleep_for(250ms);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lチカと変数の表示"><a class="header" href="#lチカと変数の表示">Lチカと変数の表示</a></h1>
<p>プロジェクトの作成は省略する。FrameworkでMbedOSを選択すれば問題ない。</p>
<pre><code class="language-cpp : main.cpp">#include &lt;mbed.h&gt;

int main(void){
    while(true){
        printf("HelloWorld!\r\n");
        ThisThread::sleep_for(500ms);
    }
}
</code></pre>
<p>これは<code>500ms</code>ごとに<code>HelloWorld!</code>と出力するプログラム。<code>OS6</code>から<code>Serial</code>クラスがなくなり、<code>PC</code>へはそのまま<code>printf</code>で出力できるようになった。しかし、ボードレートは<code>9600</code>である。</p>
<pre><code class="language-cpp : main.cpp">#include &lt;mbed.h&gt;

DigitalOut led(PA_1);

int main(void){
    int i = 0;
    while(true){
        led.write(i);
        printf("%d\n",i);
        i = !i;
        ThisThread::sleep_for(500ms);
    }
}
</code></pre>
<p>これは<code>500ms</code>ごとにLEDを点滅させその値を出力するプログラム。</p>
<pre><code class="language-cpp : main.cpp">#include &lt;mbed.h&gt;

DigitalOut led(PA_1);
DigitalIn sw(PB_0);

int main(void){
    int i;
    while(true){
        i = sw.read();
        led.write(i);
        printf("%d\n",i);
    }
}
</code></pre>
<p>これはスイッチの値をLEDに出力するプログラム。LEDが<code>PA_1</code>でスイッチが<code>PB_0</code>に接続する。</p>
<h2 id="参考-3"><a class="header" href="#参考-3">参考</a></h2>
<ul>
<li><a href="https://jhalfmoon.com/dbc/2022/09/29/%E3%83%A2%E3%83%80%E3%83%B3os%E3%81%AE%E3%81%8A%E7%A0%82%E5%A0%B449-mbed-os6%E3%80%81%E3%80%8Cserial%E3%80%8D%E3%81%9D%E3%81%86%E3%81%84%E3%81%88%E3%81%B0%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3/">モダンOSのお砂場(49) Mbed OS6、「Serial」そういえばなくなってたのね</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwm出力"><a class="header" href="#pwm出力">PWM出力</a></h1>
<p>LEDの明るさを<code>0</code>と<code>1</code>以外にする。<code>DigitalOut</code>ではLEDは最大で点灯か消灯の2パターンしかない。ほんのり光るなどということをするためにPWM波形を出力する。</p>
<pre><code class="language-cpp : main.cpp">#include &lt;mbed.h&gt;

using namespace ThisThread;

PwmOut led(PA_1);

int main(void){
    led.period_us(83);
    double i;
    while(true){
        for(i = 0;i &lt; 1;i+=0.01){
            led.write(i);
            printf("%.2f\n",i);
            sleep_for(25ms);
        }
        for(i = 1;i &gt; 0;i-=0.01){
            led.write(i);
            printf("%.2f\n",i);
            sleep_for(25ms);
        }
    }
}
</code></pre>
<p><code>led</code>に周期<code>83us</code>のPWM波形を出力。<code>Mbed</code>では<code>0~1</code>の間で少数でデューティー比を決める。<br />
このプログラムではだんだん明るくなり、暗くなるを1セットとしそれを繰り返すプログラム。</p>
<h2 id="参考-4"><a class="header" href="#参考-4">参考</a></h2>
<ul>
<li><a href="https://os.mbed.com/users/okini3939/notebook/PwmOut_jp/">PwmOut - PWM出力</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可変抵抗を読む"><a class="header" href="#可変抵抗を読む">可変抵抗を読む</a></h1>
<p>可変抵抗の値を読みPWMとして出力する。</p>
<pre><code class="language-cpp : main.cpp">#include &lt;mbed.h&gt;

using namespace ThisThread;

PwmOut led(PA_1);
AnalogIn resi(PA_0);

int main(void){
    led.period_us(83);
    float i;
    while(true){
        i = resi.read();
        led.write(i);
        printf("%.7f\n",i);
    }
}
</code></pre>
<p>可変抵抗を<code>resi</code>で読み取りそれを<code>led</code>に横流しする。</p>
<p>以上。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printfでfを使用できるようにする"><a class="header" href="#printfでfを使用できるようにする">printfで%fを使用できるようにする</a></h1>
<p>デフォルトでは<code>printf("%f\n"i);</code>みたいなことはできない。少数を出力するためには設定が必要。</p>
<h2 id="設定ファイルを作成する"><a class="header" href="#設定ファイルを作成する">設定ファイルを作成する</a></h2>
<p><code>platformIO</code>のプロジェクトのディレクトリ(<code>platformio.ini</code>がある階層)に<code>mbed_app.json</code>を作成する。</p>
<pre><code class="language-json : mbed_app.json">{
    "target_overrides":{
        "*":{
            "target.printf_lib":"std"
        }
    }
}
</code></pre>
<p>以上。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コントローラーのデータ受信サンプルmbed-os6の使用方法dualshock4"><a class="header" href="#コントローラーのデータ受信サンプルmbed-os6の使用方法dualshock4">コントローラーのデータ受信サンプル(Mbed OS6)の使用方法(DUALSHOCK4)</a></h1>
<p>筆者は作成者ではないので正確な情報ではないがある程度はあっていると思う。<br />
技術継承資料では<code>Mbed OS2</code>のため<code>OS6</code>では使用できない。サンプルコードは存在するのでそれについて、軽く中身の紹介</p>
<h2 id="使い方"><a class="header" href="#使い方">使い方</a></h2>
<ul>
<li>使用したいプロジェクト内の<code>lib</code>フォルダなどのヘッダファイルなどを入れる場所に<code>SerialCtrl.h</code>,<code>SerialCtrl.cpp</code>,<code>DualShock4.h</code>をコピーする</li>
<li>使用したいソースファイル内で<code>SerialCtrl.h</code>を<code>include</code>する
<ul>
<li><code>#include "SerialCtrl.h"</code></li>
</ul>
</li>
<li>名前空間<code>NITSC</code>を使用するように設定する
<ul>
<li><code>using namespace NITSC</code></li>
</ul>
</li>
<li><code>mbed</code>の<code>UnbufferedSerial</code>クラスのインスタンスを作成する
<ul>
<li><code>fep</code>から<code>UART</code>を用いてデータを受信するため作成する</li>
<li>引数は<code>UART</code>の<code>TX</code>,<code>RX</code>,<code>baudrate</code>の順で渡す</li>
</ul>
</li>
<li><code>SerialCtrl</code>クラスのインスタンスを作成する
<ul>
<li>引数はさきほど作成した<code>UnbufferedSerial</code>のインスタンスを渡す</li>
</ul>
</li>
</ul>
<h2 id="メソッドコンストラクタクラス内で宣言されている関数"><a class="header" href="#メソッドコンストラクタクラス内で宣言されている関数">メソッド・コンストラクタ(クラス内で宣言されている関数)</a></h2>
<p>ここでは使用できる関数(public)のみ紹介</p>
<h3 id="serialctrlコンストラクタ"><a class="header" href="#serialctrlコンストラクタ"><code>SerialCtrl()</code>(コンストラクタ)</a></h3>
<ul>
<li>インスタンスを作成する際に呼び出す特別なメソッド</li>
<li>引数は<code>mbed</code>の<code>UnbufferedSerial</code>クラスのインスタンスの参照</li>
</ul>
<h3 id="tryreceive"><a class="header" href="#tryreceive"><code>tryReceive()</code></a></h3>
<ul>
<li>受信を行うメソッド</li>
<li>受信に成功した場合は<code>true</code>,そうでない場合は<code>false</code>が返ってくる</li>
</ul>
<h3 id="getdata"><a class="header" href="#getdata"><code>getData()</code></a></h3>
<ul>
<li>受信したデータを</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platformioで書き込めませんでした記録"><a class="header" href="#platformioで書き込めませんでした記録">PlatformIOで書き込めませんでした記録</a></h1>
<pre><code class="language-shell : ターミナル">/.pio/build/nucleo_f446re/stm32f446xe.ld.link_script.ld: Invalid argument
collect2.exe: error: ld returned 1 exit status
*** [.pio\build\nucleo_f446re\firmware.elf] Error 1
</code></pre>
<p>このようなエラーが書き込み時、ビルド時にでてきて書き込み等ができませんでした。解決した方法をメモとして記録しておきます。</p>
<h2 id="言われたこと"><a class="header" href="#言われたこと">言われたこと</a></h2>
<p><strong>もしかしたら<code>main.cpp</code>(メインとなるソースファイル)がプロジェクト内に複数あるかも</strong><br />
プロジェクトの最上位層(<code>.pio</code>が入っているフォルダ)で次のコマンドを実行。それにより1つしかプロジェクト内にないことが判明。</p>
<pre><code class="language-bash : terminal">ls -laR . | grep main
</code></pre>
<pre><code class="language-bash : 実行結果">-rw-r--r-- 1 [User] 197609 912 Jun  7 09:23 main.cpp
</code></pre>
<p>を得た。これによりこの階層以下に<code>main</code>を含むファイルが1つしかないことが分かる。</p>
<p><strong>参照しているライブラリ等と同じ名前のファイルが存在してるかも</strong><br />
<code>#include &lt;mbed.h&gt;</code>を<code>#include "mbed.h"</code>に変更してみてやってみたけど何も変わらなかった。</p>
<h2 id="解決した方法"><a class="header" href="#解決した方法">解決した方法</a></h2>
<p>単純にプロジェクトを置いてる場所が悪かった。今で置いていたところは<code>PC/d/学校のOneDrive/gitリポジトリ/</code>に置いていて多分学校のOneDriveがとても長いし空白を含んでいるからだめだったのかと思う。<br />
OneDriveの中にローカルリポジトリを置くなんて頭悪いことしないように！</p>
<h2 id="変更後"><a class="header" href="#変更後">変更後</a></h2>
<p>ローカルリポジトリをユーザー直下に置いてみた。これで解決したけどwindowsの場合はユーザーフォルダが<code>PC/Windows/ユーザー/[User Name]/</code>みたいに日本語になっていると思われるのでこれでもだめだったらWindowsとか別のUSBとかにいれるのをおすすめする。基本的にファイル名やフォルダ名を半角英数字のみで構成することをとてもおすすめするいい経験となった。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32cubeideでの開発"><a class="header" href="#stm32cubeideでの開発">STM32CubeIDEでの開発</a></h1>
<p>基本的に<code>NUCLEO-F446RE</code>を用いた。2024年度春休みに<code>Keil Studio</code>でない開発環境を使用するために使用してみた。その時の記録。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/BasicContentsHome.html">はじめにやっておくと便利になること</a>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/printf.html"><del>変数などを表示するために</del></a></li>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/printfLibrary.html">変数などを簡単に表示するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/manydef.html">ピンの名前などを簡単に入力するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./BasicContents/generateBinaryFile.html">バイナリファイル(.bin)の生成</a></li>
</ul>
</li>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/InOutHome.html">入出力の基本について</a>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/digitalInOut.html">ディジタル入出力をする</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/OutTimerLED.html">タイマー割り込みでLチカ</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/OutPWM.html">PWM出力する</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/InVariableResistance.html">可変抵抗の値を読む</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./InOut/InRotaryEncoder.html">ロータリーエンコーダーを読む</a></li>
</ul>
</li>
<li><a href="DevelopmentSTM32CubeIDE/./Connectability/ConnectabilityHome.html">通信について</a>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/./Connectability/uartReceive.html">UART通信(受信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./Connectability/uartTransmit.html">UART通信(送信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./Connectability/ConnectArduino.html">Arduinoとの通信</a></li>
<li><a href="DevelopmentSTM32CubeIDE/./Connectability/canReceive.html">CAN通信(受信)</a></li>
</ul>
</li>
</ul>
<h2 id="開発を始める前に"><a class="header" href="#開発を始める前に">開発を始める前に</a></h2>
<ul>
<li><a href="https://qiita.com/usashirou/items/65be086c28f7a6feac7d"><code>STM32CubeIDE</code>の導入</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本的なこと"><a class="header" href="#基本的なこと">基本的なこと</a></h1>
<p>ここではプロジェクトを作成した後にやっておくと便利なことを軽く解説。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html"><del>変数などを表示するために</del></a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printfLibrary.html">変数などを簡単に表示するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./manydef.html">ピンの名前などを簡単に入力するために</a></li>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./generateBinaryFile.html">バイナリファイル(.bin)の生成</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数などを表示するために"><a class="header" href="#変数などを表示するために">変数などを表示するために</a></h1>
<h2 id="printfを使って変数の値などを見れるようにする"><a class="header" href="#printfを使って変数の値などを見れるようにする">printfを使って変数の値などを見れるようにする</a></h2>
<p>マイコンとパソコンとの間で<code>UART</code>を用いて通信を行う。パソコン側では<code>TeraTerm</code>を用いてシリアルポートを監視する。</p>
<h2 id="cubeideの設定"><a class="header" href="#cubeideの設定">CubeIDEの設定</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART2</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART2</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
/* USER CODE END Includes */

/* USER CODE BEGIN 1 */
setbuf(stdout,NULL);
/* USER CODE END 1 */

/* USER CODE BEGIN 3 */
    printf("Hello World\r\n");
    HAL_Delay(250);
}
/* USER CODE END 3 */

/* USER CODE BEGIN 4 */
int _write(int file,char *ptr,int len){
    HAL_UART_Transmit(&amp;huart2, (uint8_t *)ptr, len, 10);
    return len;
}
/* USER CODE END 4 */
</code></pre>
<h2 id="teratermの設定"><a class="header" href="#teratermの設定">TeraTermの設定</a></h2>
<p><code>TeraTerm</code>を開いて<code>ファイル</code>-<code>新しい接続</code>-<code>シリアル</code>-<code>COM◯: STMicroelectronics STLink Virtual COM Port (COM◯)</code>-<code>OK</code>でマイコンと接続する。<code>設定</code>-<code>シリアルポート</code>-<code>スピード</code>を<code>CubeIDE</code>側で設定した<code>Baud Rate</code>を入力。ここでは<code>38400</code>と設定。<code>現在の接続を再設定</code>で設定を完了させる。</p>
<h3 id="参考-5"><a class="header" href="#参考-5">参考</a></h3>
<ul>
<li><a href="https://yukblog.net/stm32cubeide-printf-uart/">【便利】STM32CubeIDEでprintf【UART編】</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数などを簡単に表示するために"><a class="header" href="#変数などを簡単に表示するために">変数などを簡単に表示するために</a></h1>
<p><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html">'変数などを表示するために'</a>で<code>printf</code>する方法を紹介したが、いちいち<code>int _write</code>とか書くのがめんどくさくなったので処理をまとめた。</p>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART2</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART2</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "STprintf.h"
/* USER CODE END Includes */

/* USER CODE BEGIN 2 */
STprintf(&amp;huart2);
uint8_t Out[8] = {0};
/* USER CODE END 2 */

/* USER CODE BEGIN 3 */
    printf("Hello World\r\n");
    HAL_Delay(250);
}
/* USER CODE END 3 */

</code></pre>
<p><code>STprintf</code>関数の引数にUARTのポインタを渡すだけで<code>printf</code>が使えるようになる。</p>
<h2 id="teratermの設定-1"><a class="header" href="#teratermの設定-1">TeraTermの設定</a></h2>
<p><code>TeraTerm</code>を開いて<code>ファイル</code>-<code>新しい接続</code>-<code>シリアル</code>-<code>COM◯: STMicroelectronics STLink Virtual COM Port (COM◯)</code>-<code>OK</code>でマイコンと接続する。<code>設定</code>-<code>シリアルポート</code>-<code>スピード</code>を<code>CubeIDE</code>側で設定した<code>Baud Rate</code>を入力。ここでは<code>38400</code>と設定。<code>現在の接続を再設定</code>で設定を完了させる。</p>
<h3 id="参考-6"><a class="header" href="#参考-6">参考</a></h3>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/BasicContents/./printf.html">変数などを表示するために</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="名前を楽するlib"><a class="header" href="#名前を楽するlib">名前を楽する(lib)</a></h1>
<p><code>GPIOA</code>とか<code>GPIO_PIN_1</code>とか<code>TIM_Channel_3</code>とか書くのがめんどくなったので楽にした。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">もともと</th><th style="text-align: center">いま</th></tr></thead><tbody>
<tr><td style="text-align: center">GPIO_PIN_0</td><td style="text-align: center">P0</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIO_PIN_15</td><td style="text-align: center">P15</td></tr>
<tr><td style="text-align: center">GPIO_PIN_ALL</td><td style="text-align: center">Pall</td></tr>
<tr><td style="text-align: center">GPIO_PIN_0</td><td style="text-align: center">GPIO_Pin_0</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIO_PIN_15</td><td style="text-align: center">GPIO_Pin_15</td></tr>
<tr><td style="text-align: center">GPIO_PIN_ALL</td><td style="text-align: center">GPIO_Pin_ALL</td></tr>
<tr><td style="text-align: center">GPIOA</td><td style="text-align: center">PA</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">GPIOH</td><td style="text-align: center">PH</td></tr>
<tr><td style="text-align: center">TIM_CHANNEL_1</td><td style="text-align: center">TIMCH_1</td></tr>
<tr><td style="text-align: center">中略</td><td style="text-align: center">中略</td></tr>
<tr><td style="text-align: center">TIM_CHANNEL_4</td><td style="text-align: center">TIMCH_4</td></tr>
<tr><td style="text-align: center">TIM_CHANNWL_ALL</td><td style="text-align: center">TIMCH_ALL</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="バイナリファイルbinの生成"><a class="header" href="#バイナリファイルbinの生成">バイナリファイル(.bin)の生成</a></h1>
<h2 id="エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する"><a class="header" href="#エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する">エクスプローラーなどからマイコンに直接書き込めるようにbinファイルを生成する</a></h2>
<p><code>CubeIDE</code>では<code>binファイル</code>は実行時やデバッグ時に自動で生成され、実行時、デバッグ時毎に上書き保存される。設定を変更するだけで生成されるようになる。<br />
<code>[プロジェクト名]</code>を右クリック、<code>プロパティ</code>-<code>C/C++ ビルド</code>-<code>設定</code>-<code>ツール設定</code>-<code>MCU/MPU Post build outputs</code>の<code>Convert to binary file</code>の項目にチェックを入れ、適用して閉じる。
<code>binファイル</code>の他にも<code>HEXファイル</code>や<code>SRECファイル</code>などの他のファイル形式のファイルも設定すれば、生成できる。<br />
<code>binファイル</code>は生成されるとプロジェクトの中の<code>Debugフォルダ</code>に<code>[プロジェクト名].bin</code>という名前で生成される。</p>
<h3 id="参考-7"><a class="header" href="#参考-7">参考</a></h3>
<ul>
<li><a href="https://yukblog.net/stm32cubeide-hex/">STM32CubeIDEでHEXファイルを作成する方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入出力"><a class="header" href="#入出力">入出力</a></h1>
<p>ディジタルやアナログの入出力に関して軽く解説。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./digitalInOut.html">ディジタル入出力をする</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./OutTimerLED.html">タイマー割り込みを使用したLチカ</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./OutPWM.html">PWM出力をする(タイマー)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./InVariableResistance.html">可変抵抗の値を読む(アナログ入力・タイマー)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/InOut/./InRotaryEncoder.html">ロータリーエンコーダーを読む(タイマー)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ディジタル入出力"><a class="header" href="#ディジタル入出力">ディジタル入出力</a></h1>
<h2 id="ledを点灯させたりプッシュスイッチの値を読み込んだりする"><a class="header" href="#ledを点灯させたりプッシュスイッチの値を読み込んだりする">LEDを点灯させたり、プッシュスイッチの値を読み込んだりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Pinout view</code>から使いたいピンを選択する。今回は<code>PA_1</code>を<code>GPIO_Input</code>、<code>PA_0</code>を<code>GPIO_Output</code>に設定した。ピンを選ぶときには使用するマイコンボードのMbedのページ(ここでは<a href="https://os.mbed.com/platforms/ST-Nucleo-F446RE/">'NUCLEO-F446RE'</a>)の<code>Morpho headers</code>を見ながら選ぶといいかもしれない。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN 2 */
int psw1;
/* USER CODE END 2 */

/* USER CODE BEGIN 3 */
    psw1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1); // ディジタル入力
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, psw1); // ディジタル出力
}
/* USER CODE END 3 */
</code></pre>
<p>使用する回路によって動作は異なるがプルアップ抵抗を用いたプッシュスイッチの回路であれば、スイッチを押すとLEDは消灯し、離すとLEDは点灯するだろう。</p>
<h3 id="参考-8"><a class="header" href="#参考-8">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/30e522589db9f7dc8fe4">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(4) スイッチを使ってみよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="タイマー割り込みによるlチカ"><a class="header" href="#タイマー割り込みによるlチカ">タイマー割り込みによるLチカ</a></h1>
<h2 id="hal_delayを使わないでlチカをする"><a class="header" href="#hal_delayを使わないでlチカをする">HAL_Delay()を使わないでLチカをする</a></h2>
<p>今までLチカは以下のようなコードでしていた。</p>
<pre><code class="language-c : main.c">HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_0);
HAL_Delay(1000);
</code></pre>
<p>これは毎秒Lチカするプログラムである。このコードでは次にLEDの状態を変えるまで処理をすべて止めている。そのため、他の処理をしようとしてもできなかった。そんなときにタイマー割り込みを使用すれば他の処理を止めることなく、一定の周期である処理を実行することができる。<br />
<code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM2</code>-<code>Mode</code>-<code>Clock Source</code>を<code>Internal Clock</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Prescaler</code>を<code>15</code>、<code>Counter Period</code>を<code>999999</code>に、<code>Configuration</code>-<code>NVIC Setting</code>-<code>TIM2 global interrupt</code>を<code>Enable</code>に設定。今回は<code>TIM2</code>を使用した。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN 2 */
HAL_TIM_Base_Start_IT(&amp;htim2);
/* USER CODE END 2 */

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){
    HAL_GPIO_TogglePin(GPIOxA, GPIO_Pin_0);
}
/* USER CODE END 4 */
</code></pre>
<p><code>HAL_TIM_PeriodElapsedCallback</code>関数は割り込みをした時に実行される関数であるため、そこにLチカのコードを書く。<br />
割り込み周期は設定した<code>Prescaler</code>と<code>Counter Period</code>、内部クロック周波数で決まる。内部クロック周波数はデフォルトでは<code>16MHz</code>だが変更したいまたは。確認したい場合は<code>ioc</code>ファイルの<code>Clock Configuration</code>-<code>APB1 Timer clocks(MHz)</code>で確認する(たぶん)。割り込み周期は以下の式で求められる。<br />
$$f = \frac{(内部クロック周波数)}{(Prescaler + 1) \times (Counter \space Period + 1)}$$<br />
また、周期は周波数の逆数なので周期から求めると、<br />
$$ T = \frac{1}{f} = \frac{(Prescaler + 1) \times (Counter \space Period + 1)}{(内部クロック周波数)} $$<br />
となる。おすすめとしては<code>Prescaler</code>を<code>15</code>として<code>Counter Period</code>の値を変更するとわかりやすいかもしれない。<br />
上記の例では<code>Prescaler</code>が<code>15</code>で<code>Counter Period</code>が<code>999999</code>なので周期は、<br />
$$ \frac{(15 + 1)(999999 + 1)}{16 \times 10^6} = 1[s] $$<br />
となり、毎秒Lチカするプログラムになっている。</p>
<h3 id="参考-9"><a class="header" href="#参考-9">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/e02b798b4bf1b92a4546">STM32CubeIDEを使ってみよう How To STM32CubeIDE 日本語版 (15) TimerでLチカしよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwm出力-1"><a class="header" href="#pwm出力-1">PWM出力</a></h1>
<h2 id="ledの明るさを変更したりモーターの回転速度を変更したりする"><a class="header" href="#ledの明るさを変更したりモーターの回転速度を変更したりする">LEDの明るさを変更したり、モーターの回転速度を変更したりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM3</code>-<code>Mode</code>-<code>Channel3</code>を<code>PWM Generation CH3</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Prescaler</code>を<del><code>83</code></del><code>4</code>、<code>Counter Period</code>を<del><code>999</code></del><code>255</code>、<code>PWM Generation Channel3</code>-<code>Output compare preload</code>を<code>Disable</code>に設定。今回は<code>TIM3</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN WHILE */
while (1)
{
    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    __HAL_TIM_SET_COMPARE(&amp;htim3,TIM_CHANNEL_3,100);
}
/* USER CODE END 3 */
</code></pre>
<p><code>100</code>がパルス幅にあたる部分であり、範囲は<code>0</code>~<code>255</code>にする。<br />
範囲やPWM周期などは<code>Prescaler</code>や<code>Counter Period</code>などから求められる。式については<a href="DevelopmentSTM32CubeIDE/InOut/./OutTimerLED.html">'ここ'</a>に記載している。<code>Counter Period</code>が<code>範囲の個数-1</code>であるということだけは覚えていて欲しい。</p>
<h3 id="参考-10"><a class="header" href="#参考-10">参考</a></h3>
<ul>
<li><a href="https://moons.link/post-632/">STM32 HALを使ってPWM出力してみる</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アナログ入力"><a class="header" href="#アナログ入力">アナログ入力</a></h1>
<h2 id="可変抵抗の値を読み取ったりセンサの値を読み取ったりする"><a class="header" href="#可変抵抗の値を読み取ったりセンサの値を読み取ったりする">可変抵抗の値を読み取ったり、センサの値を読み取ったりする</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Pinout view</code>から使いたいピンを選択する。今回は<code>PA_4</code>を<code>ADC1_IN4</code>に設定した。ピンを選ぶときには使用するマイコンボードのMbedのページ(ここでは<a href="https://os.mbed.com/platforms/ST-Nucleo-F446RE/">'NUCLEO-F446RE'</a>)の<code>Morpho headers</code>を見ながら選ぶといいかもしれない。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN 2 */
float resi1;
/* USER CODE END 2 */

/* USER CODE BEGIN WHILE */
while (1)
{
    HAL_ADC_Start(&amp;hadc1);
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    HAL_ADC_PollForConversion(&amp;hadc1, 100);
    resi1 = HAL_ADC_GetValue(&amp;hadc1);
    printf("%f\r\n",resi1);
    HAL_Delay(250);
}
/* USER CODE END 3 */
</code></pre>
<p><code>float</code>型を<code>printf</code>するために、設定を変更する。<code>[プロジェクト名]</code>を右クリック、<code>プロパティ</code>-<code>C/C++ ビルド</code>-<code>設定</code>-<code>ツール設定</code>-<code>MCU/MPU Settings</code>の<code>Use float with printf from newlib-nano</code>の項目にチェックを入れ、適用して閉じる。<br />
今回は可変抵抗を用いてアナログ入力値の変化を出力した。<code>printf</code>を使えるようにするためには、他の設定やコードが必要。<a href="DevelopmentSTM32CubeIDE/InOut/../BasicContents/printfLibrary.html">'これ'</a>を参考にした。</p>
<h3 id="参考-11"><a class="header" href="#参考-11">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/e6b5d0529524a140ebaf">STM32CubeIDEを使ってみよう How To STM32CubeIDE 日本語版 (12) ADCを使ってみよう</a></li>
<li><a href="https://yukblog.net/stm32cubeide-printf-float/">STM32CubeIDEのprintfでfloatが使えない件の対処方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ロータリーエンコーダを読む"><a class="header" href="#ロータリーエンコーダを読む">ロータリーエンコーダを読む</a></h1>
<p>エンコーダは<a href="https://www.digikey.jp/ja/products/detail/same-sky-formerly-cui-devices-/AMT102-V/827015?gclsrc=aw.ds&amp;&amp;utm_adgroup=&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=Pmax%20Shopping_Product_Medium%20ROAS&amp;utm_term=&amp;productid=827015&amp;utm_content=&amp;utm_id=go_cmp-20190420439_adg-_ad-__dev-c_ext-_prd-827015_sig-Cj0KCQjwhMq-BhCFARIsAGvo0KepiliL5UMokL4bXzAq1rxj0amR6aMMbkjXr6ANuMr8IIp5-BnlpJoaArLIEALw_wcB&amp;gad_source=1&amp;gclid=Cj0KCQjwhMq-BhCFARIsAGvo0KepiliL5UMokL4bXzAq1rxj0amR6aMMbkjXr6ANuMr8IIp5-BnlpJoaArLIEALw_wcB&amp;gclsrc=aw.ds">'AMT102-V'</a>を使用した。</p>
<p>エンコーダを読むことで移動距離などを計算できる。エンコーダにはA相とB相を用いて回転方向と回転量をアナログ値として読み取ることができるらしい。<br />
<code>Timer</code>のエンコーダモードを使用する。使用するピンは各<code>Timer</code>の<code>Channel1,2</code>である。<br />
<code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Timers</code>-<code>TIM3</code>-<code>Mode</code>-<code>Combined Channels</code>を<code>Encoder Mode</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Counter Settings</code>-<code>Counter Period</code>を<code>8192</code>、<code>Encoder</code>-<code>Encoder Mode</code>を<code>Encoder Mode TI1 and TIT2</code>に設定。今回は<code>TIM3</code>を使用した。<br />
<code>printf</code>を使用する。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN 0 */
int over;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){
    if(htim-&gt;Instance == TIM3){
        __HAL_TIM_CLEAR_FLAG(&amp;htim3,TIM_IT_UPDATE);
        if(__HAL_TIM_IS_TIM_COUNTING_DOWN(&amp;htim3)){
            over--;
        }else{
            over++;
        }
    }
}
/* USER CODE END 0 */

/* USER CODE BEGIN 2 */
STprintf(&amp;huart2);
HAL_TIM_Encoder_Start(&amp;htim3, TIMCH_ALL);
HAL_TIM_Base_Start_IT(&amp;htim3);
int count;
over = 0;
/* USER CODE END 2 */

/* USER CODE BEGIN WHILE */
while (1)
{
    // count = TIM3 -&gt; CNT;
    count = (long)(over * 8192) + (long)TIM3 -&gt; CNT;
    printf("%d\r\n",count);
    HAL_Delay(100);
/* USER CODE END WHILE */
</code></pre>
<p>エンコーダの回転量を<code>TIM3 -&gt; CNT</code>でゲットし表示する。ただ<code>8192</code>を上回るまたは<code>0</code>を下回ると<code>8192</code>から<code>0</code>にまたは<code>0</code>から<code>8192</code>に飛ぶ。<br />
それを解決するためにオーバーフローを検知しその回数を記録し<code>count</code>に反映させる。<code>HAL_TIM_PeriodElapsedCallback</code>関数はオーバーフローが起こった時に実行される関数であるため、そこにオーバーフローの回数を記録する。一回転が<code>8192</code>であるから<code>over * 8192</code>で増分を増やす。一回転が<code>8192</code>であるのはエンコーダのデータシートに記載されていて内部のディップスイッチが<code>1</code>~<code>4</code>までが全て<code>0</code>になっている場合、一回転は<code>2048 * 4</code>の<code>8192</code>になると書かれている。<br />
![encoder_inside.JPG](../../resources/DevelopmentSTM32CubeIDE/InOut/InRotaryEncoder/encoder_inside.JPG =400x center)</p>
<h2 id="角度を求めてみる"><a class="header" href="#角度を求めてみる">角度を求めてみる</a></h2>
<p>回転量から回転回数や基準からの角度などを求められる。<code>((float)count / 8192) * 360</code>で1周<code>360°</code>になる。ただし<code>count</code>はもともと<code>int</code>型なので計算結果を少数にするために<code>float</code>型にキャスト変換する。また、以下のコードで角度を<code>0°</code>~<code>360°</code>にすることで何周しても同じ角度になるようにすることができる。</p>
<pre><code class="language-c : main.c">while(deg &gt; 360){
    deg = deg - 360;
}
while(deg &lt; 0){
    deg = deg + 360;
}
</code></pre>
<p>また、スイッチが押されたらその場所を基準としてそこからの角度を表示できるようにすると良いかもしれない。するとすれば<code>over</code>と<code>TIM3-&gt;CNT</code>をそれぞれ<code>0</code>にする必要がある。<br />
![deg.png](../../resources/DevelopmentSTM32CubeIDE/InOut/InRotaryEncoder/deg.png =250x center)</p>
<h3 id="参考-12"><a class="header" href="#参考-12">参考</a></h3>
<ul>
<li><a href="https://www.shujima.work/entry/2019/05/28/221629">【Nucleo入門】Nucleo-F401でエンコーダ読み取り(STM32CubeIDE、macOS版)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通信"><a class="header" href="#通信">通信</a></h1>
<p>他の機器と通信する方法について簡単に解説する。主に<code>UART</code>による通信について解説する。<br />
コントローラー側の<code>Arduino</code>との通信に使用するヘッダファイルなどの中身も軽く紹介する。</p>
<p><strong>コンテンツ一覧</strong></p>
<ul>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./uartReceive.html">UART通信(受信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./uartTransmit.html">UART通信(送信)</a></li>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./ConnectArduino.html">Arduinoとの通信</a></li>
<li><a href="DevelopmentSTM32CubeIDE/Connectability/./canReceive.html">CAN通信(受信)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart通信受信"><a class="header" href="#uart通信受信">UART通信(受信)</a></h1>
<h2 id="arduinoなどからのデータをuartを使用して受け取る"><a class="header" href="#arduinoなどからのデータをuartを使用して受け取る">ArduinoなどからのデータをUARTを使用して受け取る</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">/* USER CODE BEGIN 2 */
char getdata;
/* USER CODE END 2 */

/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
    if(HAL_UART_Receive(&amp;huart1, &amp;getdata, 1, 10) == HAL_OK){
        printf("%x\r\n",getdata);
    }
}
/* USER CODE END 3 */
</code></pre>
<p>受け取ったデータを<code>printf</code>する。たとえば<code>Arduino</code>側でスイッチの値を送るとしたら<code>TeraTerm</code>の画面にはそのスイッチの値が表示されるだろう。</p>
<h3 id="参考-13"><a class="header" href="#参考-13">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/5a2c9e4fd35c261c4f3a">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(6) 　UARTを使ってみよう(2)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart通信送信"><a class="header" href="#uart通信送信">UART通信(送信)</a></h1>
<h2 id="arduinoなどにデータをuartを使用して送る"><a class="header" href="#arduinoなどにデータをuartを使用して送る">ArduinoなどにデータをUARTを使用して送る</a></h2>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。<br />
保存しコードを作成。<code>main.c</code>に処理を追記。</p>
<pre><code class="language-c : main.c">STprintf(&amp;huart2);
uint8_t i = 0;

/* USER CODE END 2 */

/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    HAL_UART_Transmit(&amp;huart1, &amp;i, 1, 10);
    printf("%d\r\n",i);
    HAL_Delay(250);
    i++;
}
</code></pre>
<p><code>HAL_UART_Transmit</code>でUARTを使用して<code>1Byte</code>のデータを送信する。<code>printf</code>で<code>i</code>の値を画面上に出力している。</p>
<h3 id="参考-14"><a class="header" href="#参考-14">参考</a></h3>
<ul>
<li><a href="https://qiita.com/usashirou/items/76c812d35642a3c29aea">STM32CubeIDEを使ってみよう　How To STM32CubeIDE 日本語版　(5) 　UARTを使ってみよう</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arduinoとの通信lib"><a class="header" href="#arduinoとの通信lib">Arduinoとの通信(lib)</a></h1>
<h2 id="keil-studioのserialctrlのようなライブラリの使用方法"><a class="header" href="#keil-studioのserialctrlのようなライブラリの使用方法">Keil StudioのSerialCtrlのようなライブラリの使用方法</a></h2>
<ol>
<li>
<p><code>UART_Arduinoライブラリ</code>の最新バージョンをダウンロード。</p>
<p><code>teams</code>等にある場合が多い。</p>
 <!-- または`github`上にある。[ここ](https://github.com/s2301089/development-F446RE/tree/main/lib/UART_Arduino)からダウンロード。   -->
</li>
<li>
<p>ダウンロードした<code>ヘッダファイル</code>を<code>プロジェクト</code>-<code>Core</code>-<code>Inc</code>に、<code>ソースファイル</code>を<code>プロジェクト</code>-<code>Core</code>-<code>Src</code>に移動。</p>
</li>
<li>
<p>使用したいソースファイル内等でヘッダファイルを<code>Include</code>する。</p>
</li>
<li>
<p>使用する<code>USART</code>を<code>.iocファイル</code>で設定しコードを生成。</p>
<p><code>[プロジェクト名].ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>USART1</code>-<code>Mode</code>を<code>Asynchronous</code>、<code>Configuration</code>-<code>Parameter Settings</code>-<code>Basic Parameters</code>-<code>Baud Rate</code>を<code>38400</code>に設定。今回は<code>USART1</code>を使用した。</p>
</li>
<li>
<p>使用する関数を記述。</p>
</li>
</ol>
<blockquote>
<p>中には<code>printf</code>を使用する関数も含まれているため、<code>printf</code>を<code>UART通信</code>で使用できるようにしておく。<a href="DevelopmentSTM32CubeIDE/Connectability/../BasicContents/printfLibrary.html">'参考'</a></p>
</blockquote>
<p><strong>使用例1</strong></p>
<pre><code class="language-c : main.c">// 略
/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "USART_Arduino.h"
/* USER CODE END Includes */
// 中略
    /* USER CODE BEGIN 1 */
    setbuf(stdout,NULL);
    /* USER CODE END 1 */
// 中略
    /* USER CODE BEGIN 2 */
    getdata DATA;
    /* USER CODE END 2 */
// 中略
    /* USER CODE BEGIN WHILE */
    while (1)
    {
    /* USER CODE END WHILE */
    /* USER CODE BEGIN 3 */
        if(getData(&amp;huart1,&amp;DATA) == 0){
            AllShowP(DATA);
        }
    }
    /* USER CODE END 3 */
// 中略
    /* USER CODE BEGIN 4 */
    int _write(int file,char *ptr,int len){
        HAL_UART_Transmit(&amp;huart2, (uint8_t *)ptr, len, 10);
        return len;
    }
    /* USER CODE END 4 */
// 略
</code></pre>
<p>上記の使用例では、<code>printf</code>を<code>USART2</code>で使用できるようにし、<code>Arduino</code>との<code>UART通信</code>に<code>USART1</code>を使用している。また、<code>getdata</code>型の<code>DATA</code>という名前の構造体変数を宣言し、<code>getData関数</code>に引数として<code>DATA</code>のアドレスを渡している。</p>
<p><strong>使用例2</strong></p>
<pre><code class="language-c : main.c">// 略
/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "USART_Arduino.h"
#include "STprintf.h"
#include "manydef.h"
/* USER CODE END Includes */
// 略
    /* USER CODE BEGIN 2 */
    STprintf(&amp;huart2);
    unsigned int FAFcount = 0;
    /* USER CODE END 2 */
// 略
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        HAL_TIM_PWM_Start(&amp;htim3,TIMCH_3);
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
        getDataIT(&amp;huart1);
        printf("%d %d \r\n",FAF,FAFcount);
        if(FAF == 1){
            FAFcount = 0;
            AllShow(data);
            __HAL_TIM_SET_COMPARE(&amp;htim3,TIMCH_3,data.LY);
            HAL_GPIO_WritePin(GPIOxA, GPIO_Pin_0, 0);
        }else{
            FAFcount++;
            if(FAFcount &gt;= TIMEOUT_MAX * 10){
                __HAL_TIM_SET_COMPARE(&amp;htim3,TIMCH_3,0);
                HAL_GPIO_WritePin(GPIOxA, GPIO_Pin_0, 0);
                FAFcount = 0;
                printf("main timeout ");
                HAL_Delay(500);
            }
        }
    }
    /* USER CODE END 3 */
// 略
</code></pre>
<p>上記の使用例では、<code>printf</code>を<code>USART2</code>で使用できるようにし、<code>Arduino</code>との<code>UART通信</code>に<code>USART1</code>を使用している。あらかじめライブラリ内で宣言されている構造体<code>data</code>の<code>LY</code>の値に合わせて<code>LED</code>が点灯する。FAFとはデータを受信したかどうか記録するフラグ(変数)であり、フラグに合わせてタイムアウトの処理を行っている。タイムアウトの時間や回数などは他の処理の量によって変更した。</p>
<h3 id="各関数に関して"><a class="header" href="#各関数に関して">各関数に関して</a></h3>
<ul>
<li>getData関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>と<code>getdata*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>と受信したデータを入れる構造体変数のポインタ<code>getdata*</code>を渡す。</li>
<li><code>getData(&amp;huart1,DATA);</code></li>
<li>戻り値は、先頭データが<code>0xaf</code>であり、構造体に受信データが代入された場合は<code>0</code>、先頭データが<code>0xaf</code>でない場合は<code>-1</code>が返される。</li>
<li>受信にはポーリング方式を使用し、データを受信する関数。</li>
</ul>
</li>
<li>getDataIT関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>を渡す。</li>
<li><code>getDataIT(&amp;huart1);</code></li>
<li>使用には<code>Configuration</code>-<code>NVIC Setting</code>-<code>USART1 global interrupt</code>を<code>Enable</code>に設定する必要がある。</li>
<li>戻り値はなく、受信には割り込み使用し、データを受信する関数。</li>
</ul>
</li>
<li>AllShow関数
<ul>
<li>引数に<code>getdata</code>をもつ。構造体変数<code>getdata</code>を渡す。</li>
<li><code>AllShow(data);</code></li>
<li>戻り値はなく、構造体の中身を表示する関数。表示形式はアナログ値をもつスティックなどは整数3桁(空白埋め)で、ディジタル値をもつボタンなどは<code>0/1</code>で表示する。</li>
<li><code>printf</code>関数を使用するため、<code>printf</code>を使用するためのコードが必要になる。<a href="DevelopmentSTM32CubeIDE/Connectability/../BasicContents/printfLibrary.html">'参考'</a></li>
</ul>
</li>
<li>AllShowP関数
<ul>
<li>引数や戻り値は<code>AllShow</code>関数と同じである。</li>
<li>表示形式はスティックなどは<code>AllShow</code>関数と同じだが、ボタンなどは<code>AllShow</code>関数と異なり、押されているボタンを名前で表示する。送信側の<code>Arduino</code>のシリアルモニタと同じように表示される。</li>
</ul>
</li>
</ul>
<h3 id="内部で使用される各関数に関して"><a class="header" href="#内部で使用される各関数に関して">内部で使用される各関数に関して</a></h3>
<ul>
<li>RevAF関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>を渡す。</li>
<li><code>RevAF(huart);</code></li>
<li>戻り値は、受信したデータが先頭データ<code>0xaf</code>の場合は<code>0xaf</code>、そうでない場合は<code>0x00</code>を、そもそも受信していない場合は<code>0xff</code>を返す。</li>
<li>ポーリング方式の際に使用される関数。</li>
</ul>
</li>
<li>AddArray関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>と<code>uint8_t*</code>をもつ。使用する<code>USART</code>の構造体変数のポインタ<code>UART_HandleTypeDef*</code>と受信したデータを入れる配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li><code>AddArray(huart,Rdata);</code></li>
<li>戻り値はなく、受信データの総数になるまで受信したデータを配列に順番に代入する。</li>
<li>ポーリング方式の際に使用される関数。</li>
</ul>
</li>
<li>HAL_UART_RxCpltCallback関数
<ul>
<li>引数に<code>UART_HandleTypeDef*</code>をもつ。この関数は受信割り込みでデータを受信した時に自動的に実行される。</li>
<li>戻り値はなく、<code>FAF</code>を揚げデータを受信したことを表す。また、<code>getData</code>関数の内部処理のようなことを行う。</li>
<li>割り込みを使用した際に使用される関数。</li>
</ul>
</li>
<li>ChSUM関数
<ul>
<li>引数に<code>uint8_t*</code>をもつ。受信したデータが入った配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li>配列の最後のデータが終端データ<code>0xed</code>であるか確認し、終端データである場合、チェックサムを行う。</li>
<li>チェックサムとは、各スティックと各ボタンのデータの総和が送信側で計算された総和と一致しているか確認すること。送信側の計算結果も受信データに含まれている。</li>
<li>戻り値は、総和が一致している場合は<code>0xed</code>、そうでない場合は<code>0x00</code>、配列の最後のデータが正しくない場合は<code>0xff</code>を返す。</li>
<li>ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
<li>AddStruct関数
<ul>
<li>引数に<code>getdata*</code>と<code>uint8_t*</code>をもち、データを格納する構造体変数のポインタ<code>getdata*</code>と受信データが入ってる配列のポインタ<code>uint8_t*</code>を渡す。</li>
<li><code>AddStruct(&amp;data,AIdata);</code></li>
<li>配列の値から構造体の各要素にデータを代入する。</li>
<li>戻り値はなく、ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
<li>StructInit関数
<ul>
<li>引数に<code>getdata*</code>をもつ。データを格納する構造体変数のポインタ<code>getdata*</code>を渡す。</li>
<li><code>StructInit(&amp;data);</code></li>
<li>構造体の各要素を初期化する。<code>LX</code>,<code>LY</code>,<code>RX</code>,<code>RY</code>スティックは<code>0x80</code>に、<code>L2</code>,<code>R2</code>スティックは<code>0x00</code>に、各ボタンは<code>0</code>に初期化される。</li>
<li>戻り値はなく、ポーリング方式と割り込みを使用した際のどちらでも使用される関数。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="can通信受信"><a class="header" href="#can通信受信">CAN通信(受信)</a></h1>
<p><code>CAN</code>とはなにか。一旦省く。<br />
<code>STM32 F446RET6</code>  <code>CAN1</code></p>
<h2 id="iocの設定can"><a class="header" href="#iocの設定can"><code>ioc</code>の設定(<code>CAN</code>)</a></h2>
<ul>
<li><code>ioc</code>-<code>Pinout &amp; Configuration</code>-<code>Connectivity</code>-<code>CAN1</code></li>
<li><code>Activated</code>にチェック</li>
<li><code>Parameter Settings</code>
<ul>
<li><code>Bit Timings Parameters</code>
<ul>
<li><code>Prescaler(for Time Quantum)</code>:<code>2</code></li>
<li><code>Time Quanta in Bit Segment 1</code>:<code>5 Times</code>→<code>Tseg1</code></li>
<li><code>Time Quanta in Bit Segment 2</code>:<code>2 Times</code>→<code>Tseg2</code></li>
<li><code>ReSynchronization Jump Width</code>:<code>1 Times</code>→<code>SJW</code></li>
<li><code>Buad Rate</code>が<code>1000000 bit/s</code>になっていることを確認<br />
<code>Prescaler</code>を先に<code>2</code>にすると<code>Tseg1</code>、<code>Tseg2</code>の設定で警告が出る可能性あり</li>
<li><code>Baud Rate</code>は次の式で求められる<br />
$$ BaudRate = \frac{(内部クロック周波数)}{(Tseg1 + Tseg2 + SJW) \times Prescaler} $$</li>
</ul>
</li>
<li><code>Basic Patameters</code>
<ul>
<li><code>Automatic Bus-Off Management</code>:<code>Enable</code>←バズOFF時再起</li>
<li><code>Automatic Wake-Up Mode</code>:<code>Enable</code>←バスOFF時受信で再起</li>
<li><code>Automatic Retransmission</code>:<code>Enable</code>←<code>ACK</code>が返ってこなかった場合の再送信</li>
</ul>
</li>
</ul>
</li>
<li><code>NVIC Settings</code>
<ul>
<li><code>CAN1 RX0 interrupt</code>:<code>Enable</code>←割り込み受信RX0有効化</li>
</ul>
</li>
</ul>
<p>コードの生成</p>
<h2 id="iocの設定timer"><a class="header" href="#iocの設定timer"><code>ioc</code>の設定(<code>Timer</code>)</a></h2>
<p><code>CAN</code>の受信判定を行うため、<code>Timer</code>割り込みを有効化させる<br />
<code>1ms</code>周期の割り込み</p>
<ul>
<li><code>Timers</code>-<code>TIM5</code></li>
<li><code>Internal Clock</code>にチェック</li>
<li><code>Patameter Settings</code>
<ul>
<li><code>Counter Settings</code>
<ul>
<li><code>Prescaler</code>:<code>15</code></li>
<li><code>Counter Period</code>:<code>999</code>
割り込み周期は以下の式で求められる<br />
$$ T = \frac{(Prescaler + 1) \times (Counter \space Period + 1)}{(内部クロック周波数)} $$</li>
</ul>
</li>
</ul>
</li>
<li><code>NVIC Settings</code>
<ul>
<li><code>TIM5 global interrupt</code>:<code>Enable</code></li>
</ul>
</li>
</ul>
<h2 id="受信コード"><a class="header" href="#受信コード">受信コード</a></h2>
<pre><code class="language-c : main.c">/* USER CODE BEGIN PV */
uint32_t CAN_CO_ID = 0x010;

uint8_t can_rev_buffer[8] = {0};
bool can_rev_flag = 0;
uint16_t can_rev_count = 0;
int count = 0;
/* USER CODE END PV */

/* USER CODE BEGIN PFP */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
/* USER CODE END PFP */

    /* USER CODE BEGIN 2 */
    //  コントローラー受信
    HAL_CAN_Start(&amp;hcan1);
    HAL_CAN_ActivateNotification(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);
    
    //  1ms周期割り込み
    //  CAN受信確認用
    HAL_TIM_Base_Start_IT(&amp;htim5);



    /* USER CODE BEGIN CAN1_Init 2 */
    CAN_FilterTypeDef filter;
    filter.FilterIdHigh = 0;
    filter.FilterIdLow = 0;
    filter.FilterMaskIdHigh = 0;
    filter.FilterMaskIdLow = 0;
    filter.FilterScale = CAN_FILTERSCALE_16BIT;
    filter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    filter.FilterBank = 0;
    filter.FilterMode = CAN_FILTERMODE_IDMASK;
    filter.SlaveStartFilterBank = 14;
    filter.FilterActivation = ENABLE;

    HAL_CAN_ConfigFilter(&amp;hcan1, &amp;filter);
    /* USER CODE END CAN1_Init 2 */


/* USER CODE BEGIN 4 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan){
    CAN_RxHeaderTypeDef RxHeader;
    uint8_t RxData[8] = {0};
    if(HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;RxHeader, RxData) == HAL_OK){
        if(hcan == &amp;hcan1){
            if(RxHeader.StdId == CAN_CO_ID){
                for(int i = 0; i &lt; 8; i++){
                    can_rev_buffer[i] = RxData[i];
                }
            }
            can_rev_count++;
        }
    }
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if(htim == &amp;htim5){
        count++;
        if(count &gt;= 1000){  //  3msの送信間隔   1s間隔の受信確認
            count = 0;
            can_rev_flag = (bool)can_rev_count;
            can_rev_count = 0;
        }
    }
}
/* USER CODE END 4 */
</code></pre>
<h2 id="使用例"><a class="header" href="#使用例">使用例</a></h2>
<pre><code class="language-c : main.c">/* USER CODE BEGIN Includes */
#include "stdbool.h"
#include "stdint.h"
/* USER CODE END Includes */

/* USER CODE BEGIN PTD */
struct CAN_DS4_struct{
    uint8_t LX, LY, RX, RY, L2, R2;
    bool TRIANGLE, CIRCLE, CROSS, SQUARE, UP, RIGHT, DOWN, LEFT, L1, L3, R1, R3, SHARE, OPTIONS, PS, TOUCHPAD;

    void (* f_data_init)    (struct CAN_DS4_struct *_struct);
    void (* f_data_apply)   (struct CAN_DS4_struct *_struct, uint8_t *_data_array);
};
/* USER CODE END PTD */

/* USER CODE BEGIN PV */
uint32_t CAN_CO_ID = 0x010;
struct CAN_DS4_struct data = {0};

uint8_t can_rev_buffer[8] = {0};
bool can_rev_flag = 0;
uint16_t can_rev_count = 0;
int count = 0;
/* USER CODE END PV */

/* USER CODE BEGIN PFP */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
void can_rev_init(struct CAN_DS4_struct *_struct);
/* USER CODE END PFP */

    /* USER CODE BEGIN 2 */
    //  コントローラー受信
    HAL_CAN_Start(&amp;hcan1);
    HAL_CAN_ActivateNotification(&amp;hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);
    can_rev_init(&amp;data);
    data.f_data_init(&amp;data);
    
    //  1ms周期割り込み
    //  CAN受信確認用
    HAL_TIM_Base_Start_IT(&amp;htim5);
    /* USER CODE END 2 */

    /* USER CODE BEGIN WHILE */
    while (1)
    {
        data.TOUCHPAD |= !can_rev_flag;
        if(can_rev_flag){
            data.f_data_apply(&amp;data,can_rev_buffer);
            if(!data.TOUCHPAD){ //  非常停止SW  受信成功失敗    遠隔非常停止
                stop_flag = 0;
                if(data.OPTIONS){
                    /**
                    処理
                    **/
                }
            }else{
                stop_flag = 1;
            }
        }else{
            stop_flag = 1;
        }
    /* USER CODE END WHILE */
    }

/* USER CODE BEGIN 4 */
void can_rev_data_init(struct CAN_DS4_struct *_struct){
    _struct-&gt;LX = 0x00;
    _struct-&gt;LY = 0x00;
    _struct-&gt;RX = 0x00;
    _struct-&gt;RY = 0x00;
    _struct-&gt;L2 = 0x00;
    _struct-&gt;R2 = 0x00;

    _struct-&gt;TRIANGLE = 0;
    _struct-&gt;CIRCLE = 0;
    _struct-&gt;CROSS = 0;
    _struct-&gt;SQUARE = 0;
    _struct-&gt;UP = 0;
    _struct-&gt;RIGHT = 0;
    _struct-&gt;DOWN = 0;
    _struct-&gt;LEFT = 0;

    _struct-&gt;L1 = 0;
    _struct-&gt;L3 = 0;
    _struct-&gt;R1 = 0;
    _struct-&gt;R3 = 0;
    _struct-&gt;SHARE = false;
    _struct-&gt;OPTIONS = false;
    _struct-&gt;PS = false;
    _struct-&gt;TOUCHPAD = true;
}

void can_rev_data_apply(struct CAN_DS4_struct *_struct, uint8_t *_data_array){
    _struct-&gt;LX = _data_array[0];
    _struct-&gt;LY = _data_array[1];
    _struct-&gt;RX = _data_array[2];
    _struct-&gt;RY = _data_array[3];
    _struct-&gt;L2 = _data_array[4];
    _struct-&gt;R2 = _data_array[5];

    _struct-&gt;TRIANGLE = _data_array[6] &amp; 0x01;
    _struct-&gt;CIRCLE = (_data_array[6] &amp; 0x02) &gt;&gt; 1;
    _struct-&gt;CROSS = (_data_array[6] &amp; 0x04) &gt;&gt; 2;
    _struct-&gt;SQUARE = (_data_array[6] &amp; 0x08) &gt;&gt; 3;
    _struct-&gt;UP = (_data_array[6] &amp; 0x10) &gt;&gt; 4;
    _struct-&gt;RIGHT = (_data_array[6] &amp; 0x20) &gt;&gt; 5;
    _struct-&gt;DOWN = (_data_array[6] &amp; 0x40) &gt;&gt; 6;
    _struct-&gt;LEFT = (_data_array[6] &amp; 0x80) &gt;&gt; 7;

    _struct-&gt;L1 = _data_array[7] &amp; 0x01;
    _struct-&gt;L3 = (_data_array[7] &amp; 0x02) &gt;&gt; 1;
    _struct-&gt;R1 = (_data_array[7] &amp; 0x04) &gt;&gt; 2;
    _struct-&gt;R3 = (_data_array[7] &amp; 0x08) &gt;&gt; 3;
    _struct-&gt;SHARE = (_data_array[7] &amp; 0x10) &gt;&gt; 4;
    _struct-&gt;OPTIONS = (_data_array[7] &amp; 0x20) &gt;&gt; 5;
    _struct-&gt;PS = (_data_array[7] &amp; 0x40) &gt;&gt; 6;
    _struct-&gt;TOUCHPAD = (_data_array[7] &amp; 0x80) &gt;&gt; 7;
}

void can_rev_init(struct CAN_DS4_struct *_struct){
    _struct-&gt;f_data_init = can_rev_data_init;
    _struct-&gt;f_data_apply = can_rev_data_apply;
}
/* USER CODE END 4 */
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
